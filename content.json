{"pages":[],"posts":[{"title":"java Exception","slug":"java-Exception","date":"2018-01-19T02:15:27.000Z","updated":"2018-01-19T05:10:15.326Z","comments":true,"path":"2018/01/19/java-Exception/","link":"","permalink":"http://yoursite.com/2018/01/19/java-Exception/","excerpt":"java异常体系架构：","text":"java异常体系架构： Error是程序无法处理的错误，它是由JVM产生和抛出的。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止 Exception是程序本身可以处理的异常，这种异常分两大类： ​ 运行时异常是不检查异常，一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 ​ 非运行时异常从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能通过编译 异常处理throw ​ throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，就是打印异常消息和堆栈信息 ​ 用法：throw new Exception(“方法中存在Exception”) throws ​ throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用无力处理该异常的时候，也应该继续抛出 ​ 假设f方法抛出了A异常，则f方法有两种方式来处理A异常 ​ 1.throwsA ​ 谁调用f方法，谁处理A异常，f方法本身不处理A异常 ​ 2.try{……}catch(){……} ​ f方法本身自己来处理A异常 ​ 要抛出的异常必须是Throwable的子类 ​ throws A不表示f方法一定会抛出A类异常 ​ throws A不表示调用f方法时，必须得对A异常进行捕捉 ​ 假设A是RuntimeException的子类异常 ​ 由于RuntimeException的子类异常可以处理也可以不处理，所以编译器允许 你调用f方法时，对f方法抛出的RuntimeException子类异常不进行处理 ​ 建议： ​ 1.对throws出的所有异常进行处理 ​ 2.如果一个方法内部已经对A异常进行了处理，则就不要再throws A try catch finally ​ 1.try catch finally三个语句块均不能单独使用，try……catch、try……finally、try……catch……finally ​ 2.try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能互相访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外部 ​ 3.多个catch块的时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行 ​ 4.先catch子类异常再catch父类异常 ​ finally的作用： ​ 1.无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛出的异常类型一致，finally中的代码一定会得到执行 ​ 2.finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，能对程序的状态做统一的管理 ​ 3.通常在finally语句中可以进行资源的清除工作，如关闭打开的文件、删除临时文件等","categories":[],"tags":[{"name":"java异常","slug":"java异常","permalink":"http://yoursite.com/tags/java异常/"}]},{"title":"JsonNote","slug":"JsonNote","date":"2017-12-20T08:03:55.000Z","updated":"2018-01-20T09:19:30.628Z","comments":true,"path":"2017/12/20/JsonNote/","link":"","permalink":"http://yoursite.com/2017/12/20/JsonNote/","excerpt":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组","text":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 Json名称/值对 ：Json数据的书写格式：名称/值对（包括字段名称（在双引号中），后面写一个冒号，然后是值）”name” : “张三” Json值可以为： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true或false） 数组（在中括号中）：可以包含多个对象 12345&#123;&quot;sites&quot;:[ &#123;&quot;name&quot; : &quot;百度&quot; , &quot;url&quot; : &quot;www.baidu.com&quot;&#125;, &#123;&quot;name&quot; : &quot;谷歌&quot; , &quot;url&quot; : &quot;www.google.com&quot;&#125;, &#123;&quot;name&quot; : &quot;微博&quot; , &quot;url&quot; : &quot;www.weibo.com&quot;&#125;]&#125; Json使用JavaScript语法，和JavaScript创建对象数组，访问数组项，修改数据一样 Json文件的文件类型是：.json Json文件的MIME类型是：application/json Json对象 ： 对象语法：{“name” : “baidu” , “alexa” : 10000 , “site” : null} Json对象使用在大括号({})中书写 对象可以包含多个key/value(键值对) key必须是字符串，value可以是合法的Json数据类型(字符串，数字，对象，数组，布尔值或null) key和value中使用冒号(:)分隔 每个key/value对使用逗号(,)分隔 访问对象值：可以使用(.)来访问对象值，也可以使用([])来访问对象值 1234var myObj,x;myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; : 10000 , &quot;site&quot; : null&#125;;x = myObj.name;x = myObj[&quot;name&quot;]; 循环对象：可以使用(for-in)来循环对象的属性，在for-in循环对象的属性时，使用中括号([])来访问属性的值 1234567var myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; = 10000 , &quot;site&quot; = null&#125;;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;&lt;br&gt;&quot;;&#125;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象：Json对象中可以包含另外一个Json对象，可以使用(.)或([])来访问嵌套的Json对象 1234567891011myObj = &#123; &quot;name&quot; : &quot;baidu&quot;, &quot;alexa&quot; : 10000, &quot;sites&quot; : &#123; &quot;site1&quot; : &quot;www.baidu.com&quot;, &quot;site2&quot; : &quot;mmm.baidu.com&quot;, &quot;site3&quot; : &quot;nnn.baidu.com&quot; &#125;&#125;;x = myObj.sites.site1;x = myObj.sites[&quot;site1&quot;]; 修改值：可以使用(.)或者([])来修改Json对象的值 删除对象属性：可以使用delete关键字来删除Json对象的属性delete myObj.sites.site1 Json数组 ： Json中数组值必须是合法的Json数据类型，JavaScript中，数组值可以是Json数据类型，也可以是JavaScript的表达式，包括函数，日期和undefined Json对象中的数组：对象属性的值可以是一个数组；可以使用索引值来访问数组 循环数组：可以使用(for-in)来访问数组，也可以使用for循环 123for(i in myObj.sites)&#123; x += myObj.sites[i] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象中的数组：可以使用两个for-in或for循环来访问 修改数组值：可以使用索引值来修改数组值 删除数组元素：可以使用delete关键字来删除数组元素 JSON.parse() Json通常用于与服务器端交换数据，在接收服务器数据时一般是字符串，可以使用JSON.parse()方法将数据转换为JavaScript对象 语法：JSON.parse(text[,reviver]) 参数说明：text：必需，一个有效的字符串；reviver：可选，一个转换结果的函数，将为对象的每个成员调用此函数 从服务器端接收Json数据：可以使用Ajax从服务器请求Json数据，并解析为JavaScript对象 异常：解析数据：Json不能存储Date对象，如果需要存储，需要将其转换为字符串，之后再将字符串转换为Date对象 123456789101112var text = &apos;&#123; &quot;name&quot; : &quot;baidu&quot; , &quot;initDate&quot; : &quot;2000-01-12&quot; , &quot;site&quot; : www.baidu.com&quot; &#125;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;日期:&quot; + obj.initDate;//也可以启用reviver参数var obj = JSON.parse(text,function(key,value)&#123; if(key == &quot;initDate&quot;)&#123; return new Date(value); &#125;else&#123; return value; &#125;&#125;); JSON.stringify() 在向服务器端发送数据时一般是字符串，可以使用JSON.stringify()方法将JavaScript对象转换成字符串 语法：JSON.stringify(value[,replacer[,space]]) 参数说明： value：必需，一个有效的Json字符串 replacer：可选，用于转换结果的函数或数组。如果replacer为函数，则JSON.stringify将调用该函数，并传入每个成员的键和值，使用返回值而不是原始值，如果此函数返回undefined，则排除成员；根对象的键是一个空字符串：””。如果replacer是一个数组，则仅转换该数组中具有键值的成员，成员的转换顺序与键在数组中的顺序一样，当value参数也为数组时，将忽略replacer数组 space：可选，文本添加缩进、空格和换行符，如果space是一个数字，则返回文本在每个级别缩进指定数目的空格，如果space大于10，则文本缩进10个空格，也可以使用非数字：\\t Json使用 由于Json语法是JavaScript语法的自己，JavaScript函数eval()可用于将Json文本转换为JavaScript对象 eval()函数使用的是JavaScript编译器，可解析Json文本，然后生成JavaScript对象，必须把文本包围在括号中var obj = eval(&quot;(&quot;+txt+&quot;)&quot;);，eval()函数可编译并执行任何JavaScript代码，这隐藏了潜在的安全问题 JSONP Jsonp(JSON with Padding)是Json的一种“使用模式”，可以让网页从别的域名(网站)那获取资料，即跨域读取数据","categories":[],"tags":[{"name":"JsonNote","slug":"JsonNote","permalink":"http://yoursite.com/tags/JsonNote/"}]},{"title":"ajaxNote","slug":"ajaxNote","date":"2017-11-19T05:16:04.000Z","updated":"2018-01-20T07:59:52.928Z","comments":true,"path":"2017/11/19/ajaxNote/","link":"","permalink":"http://yoursite.com/2017/11/19/ajaxNote/","excerpt":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行","text":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行 XMLHttpRequest对象：用于在后台与服务器交换数据 ​ 创建XMLHttpRequest对象： ​ 语法：variable = new XMLHttpRequest(); ​ var xmlHttp; ​ if(window.XMLHttpRequest){ ​ xmlHttp = new XMLHttpRequest(); ​ } XMLHttpRequest请求：向服务器发送请求：open(),send() ​ xmlHttp.open(method,url,async)规定请求的类型、URL以及是否异步处理请求 ​ method：请求的类型：GET或POST ​ url：文件在服务器上的位置 ​ async：true（异步）或false（同步） ​ xmlHttp.send(string)将请求发送到服务器 ​ string：仅用于POST请求 ​ GET还是POST？ ​ 与POST相比，GET更简单也更快，并且在大部分情况下都能用。然而，在以下情况下请使用POST请求： ​ 1.无法使用缓存文件（更新服务器上的文件或数据库） ​ 2.向服务器发送大量数据（POST请求没有数据量限制） ​ 3.发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 ​ 如果希望通过GET方法发送信息，请向URL添加信息 ​ xmlHttp.open(&#39;GET&#39;,&#39;url?name=name&amp;pas=pas&#39;,true) ​ xmlHttp.send() ​ 如果希望像HTML表单那样POST数据，使用setRequestHeader()来添加http头部，然后在send()方法中规定要发送的数据 ​ xmlHttp.setRequestHeader(header,value)向请求添加http头 ​ header：规定头的名称 ​ value：规定头的值 ​ xmlHttp.open(&#39;POST&#39;,&#39;url&#39;,true); ​ xmlHttp.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;); ​ xmlHttp.send(&#39;name=name&amp;pas=pas&#39;); ​ 通过Ajax，JavaScript无需等待服务器的响应，而是在等待服务器响应时执行其他脚本，当响应就绪后进行处理。 XMLHttpRequest响应 ​ 如需要获得来自服务器的响应，使用XMLHttpRequest对象的responseText或responseXML属性 ​ responseText属性：返回字符串形式的响应数据 ​ responseXML属性：返回XML形式的响应数据 XMLHttpRequest readyState ​ onreadystatechange事件： ​ 当请求被发送到服务器时，我们需要执行一些基于响应的任务 ​ 每当readyState改变时，就会触发onreadystatechange事件 ​ readyState属性存有XMLHttpRequest的状态信息 ​ XMLHttpRequest对象的三个重要属性： ​ 1.onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用这个函数 ​ 2.readyState 存有XMLHttpRequest的状态 ​ 0：请求未初始化 ​ 1：服务器连接已建立 ​ 2：请求已接收 ​ 3：请求处理中 ​ 4：请求已完成，且响应已就绪 ​ 3.status 状态 200：’OK‘; 400：未找到页面 回调函数 ​ 回调函数是一种以参数形式传递给另一个函数的函数 ​","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Typora","slug":"Typora","date":"2017-11-12T02:54:04.000Z","updated":"2018-01-20T08:14:28.248Z","comments":true,"path":"2017/11/12/Typora/","link":"","permalink":"http://yoursite.com/2017/11/12/Typora/","excerpt":"##Markdown语法 下标** ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry:","text":"##Markdown语法 下标** ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry: 下划线 ：使用&lt;u&gt;Underline&lt;/u&gt; 产生下划线Underline 删除线 ：使用~~包裹的文本具有删除的样式删除文本 代码 ：使用`包裹的内容将会以代码样式显示 ​ pringtf() ​ 输入12345```javapublic Class HelloWorld&#123; System.out.println(&quot;Hello world!&quot;);&#125; 强调 ：使用两个*号包裹的内容会被强调 斜体 ：使用*和_包裹的内容会是斜体显示。 ​ 斜体 要显示号可以使用转义\\ 插入图片 ：可以通过拖拉的方式加入图片 插入URL连接 ：使用尖括号包裹的url将产生一个连接，例如： 如果是标准的url，则会自动产生连接 目录列表Table of Contents ：输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容 水平分割线 ：使用*或者—，然后回车，来产生水平分割线 标注 ：可以对一个词语进行[^标注] [^标注]：这是一个标注 表格 ： 一 张 表 一 张 表 数学表达式块 ：输入两个美元符号，然后回车，就可以输入数学表达式块 任务列表 ：-[]吃饭创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者未完成 吃饭 []逛街 列表 ：输入+，-，*创建无序的列表，使用任意数字开头，创建有序列表。例如： 无 序 列 表 有 序 列 表 块引用 ：使用&gt;来插入块引用 这是一个块引用 标题 ：使用#表示一级标题，##表示二级标题，依次类推，共6个标题","categories":[],"tags":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://yoursite.com/tags/Markdown语法/"}]},{"title":"Regex","slug":"Regex","date":"2017-10-20T02:57:32.000Z","updated":"2018-01-20T04:43:49.981Z","comments":true,"path":"2017/10/20/Regex/","link":"","permalink":"http://yoursite.com/2017/10/20/Regex/","excerpt":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置","text":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置 使用正则表达式： *测试字符串内的模式（可以测试输入字符串，以查看字符串内是否出现电话模式或信用卡模式，这称为数据验证） *替换文本（可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它） *基于模式匹配从字符串中提取字符串（可以查找文档内或输入域内特定的文本） java.util.regex包主要包括以下三个类： 1.Pattern类：Pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法，要创建一个Pattern对象，必须先调用其公共静态编译方法，它返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数 2.Matcher类：Matcher对象是输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher类也没有公共构造方法。需要调用Pattern对象的matcher方法来获得一个Matcher对象 3.PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误 捕获组： 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建，捕获组是通过从左至右计算其开括号来编号。例：((A)(B(C)))有四个组 可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多少个捕获组。(group(0))它代表整个表达式，但不包括在groupCount的返回值中 正则表达式语法： 其他语言中双反斜杠表示：在正则表达式中插入一个普通的反斜杠。在java中双反斜杠表示：插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。所以java的转义需要双反斜杠，java表示一位数字的正则表达式是双反斜杠d，而表示反斜杠则是四条反斜线 字符 含义 \\ 将下一字符标记为特殊字符 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结束的位置 * 零次或多次匹配前面的字符或子表达式 + 一次或多次匹配前面的字符或子表达式 ? 零次或一次匹配前面的字符或子表达式 {n} n是非负整数，正好匹配n次 {n,} n是非负整数，至少匹配n次 {n,m} n和m是非负整数，至少匹配n次，至多匹配m次 ? 在限定字符后，表示匹配模式是“非贪心模式”，即匹配尽可能短的字符串，默认是“贪心模式” . 匹配除了“\\r\\n”之外的任何单个字符 [xyz] 字符集，匹配包含的任一字符 [^xyz] 反字符集，匹配未包含的任一字符 [a-z] 字符范围，匹配指定范围内的任何字符 \\b 匹配一个字的边界，即字与空格间的位置 \\d 数字字符匹配，等效于[0-9] \\w 匹配任何字类字符，包括下划线，等效于[A-Za-z0-9] 具体类的方法参见JDK","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Git","slug":"Git","date":"2017-10-10T02:54:35.000Z","updated":"2018-01-20T03:41:08.939Z","comments":true,"path":"2017/10/10/Git/","link":"","permalink":"http://yoursite.com/2017/10/10/Git/","excerpt":"##Git Git是分布式版本控制系统Git命令","text":"##Git Git是分布式版本控制系统Git命令 git config --global user.name 设置用户名 git config --global user.email 设置用户邮箱 pwd 显示当前目录 git init 初始化git仓库 ls -ah 查看隐藏目录 git add &lt;文件名&gt; 添加文件 git commit -m &#39;本次提交说明&#39; 把文件提交到git仓库 可以同时提交多个文件，add多个，一次提交 git status 掌握仓库当前的状态 git diff 查看difference git log 查看历史纪录 显示从最近到最远的提交日志 git log --pretty=oneline 显示提交的版本号 git reset --hard HEAD^ 回退一次 HEAD^^ 回退两次…… git reset --hard 版本号 可以回到已经退过的最新版本 git reflog 记录每一次命令 HEAD指向的版本是当前的版本 cat &lt;文件名&gt; 查看文件中的内容 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 1.readme.txt自修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态 2.readme.txt已经添加到暂存区后，又做了修改，现在撤销修改就回到添加到暂存区后的状态 用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区 rm &lt;文件名&gt; 删除文件 确实要从版本库中删除该文件，那就用命令git rm 删掉，并且git commit git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” ssh-keygen -t rsa -C &#39;youremail@example.com&#39; 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的密钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以放心告诉任何人 git remote add origin git@github.com:Github账号/learngit.git 建立远程连接 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程 git push -u origin master git push origin master git checkout -b dev 创建dev分支 git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev git branch 命令查看当前分支 git checkout master 切换回master分支 git merge 命令用于合并指定分支到当前分支 git merge dev git branch -d dev 删除dev分支 git log --graph 命令可以看到分支合并图 git clone git@github.com:Github账号/learngit.git 从远程库克隆","categories":[],"tags":[{"name":"Git命令","slug":"Git命令","permalink":"http://yoursite.com/tags/Git命令/"}]}]}