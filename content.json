{"pages":[],"posts":[{"title":"金融基础知识汇总","slug":"金融基础知识汇总","date":"2018-07-11T15:11:45.000Z","updated":"2018-07-11T15:12:09.320Z","comments":true,"path":"2018/07/11/金融基础知识汇总/","link":"","permalink":"http://yoursite.com/2018/07/11/金融基础知识汇总/","excerpt":"","text":"","categories":[],"tags":[{"name":"基础金融知识","slug":"基础金融知识","permalink":"http://yoursite.com/tags/基础金融知识/"}]},{"title":"redis","slug":"redis","date":"2018-07-03T12:19:38.000Z","updated":"2018-07-03T12:19:40.000Z","comments":true,"path":"2018/07/03/redis/","link":"","permalink":"http://yoursite.com/2018/07/03/redis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"windows DOS窗口MySQL操作命令","slug":"windows-DOS窗口MySQL操作命令","date":"2018-03-01T08:49:30.000Z","updated":"2018-07-11T14:48:30.655Z","comments":true,"path":"2018/03/01/windows-DOS窗口MySQL操作命令/","link":"","permalink":"http://yoursite.com/2018/03/01/windows-DOS窗口MySQL操作命令/","excerpt":"安装并配置好MySQL之后可以使用windows下的DOS窗口进行数据库的操作。 net start mysql 启动mysql数据库 net stop mysql 关闭mysql数据库","text":"安装并配置好MySQL之后可以使用windows下的DOS窗口进行数据库的操作。 net start mysql 启动mysql数据库 net stop mysql 关闭mysql数据库 mysql -u root -p 然后输入密码后进入mysql操作 show databases; 显示你有的数据库(记得加”;”再回车) exit; 退出mysql数据库 use database 使用某个数据库 show tables 显示当前使用数据库中的表 之后便可以使用相应的SQL语句进行数据库的增删改查","categories":[],"tags":[{"name":"指令备忘","slug":"指令备忘","permalink":"http://yoursite.com/tags/指令备忘/"}]},{"title":"TestNG","slug":"TestNG","date":"2018-02-11T12:59:24.000Z","updated":"2018-03-10T07:18:06.000Z","comments":true,"path":"2018/02/11/TestNG/","link":"","permalink":"http://yoursite.com/2018/02/11/TestNG/","excerpt":"##关于TestNG TestNG是一个开源自动化测试框架，它消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。因为它在很大程度上借鉴了Java注解来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。","text":"##关于TestNG TestNG是一个开源自动化测试框架，它消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。因为它在很大程度上借鉴了Java注解来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。 特点 注解 TestNG使用Java和面向对象的功能 支持综合类测试（例如，默认情况下，不用创建一个新的测试每个测试方法的类的实例） 独立的编译时测试代码和运行时配置/数据信息 灵活的运行时配置 主要介绍“测试组” 支持依赖测试方法，并行测试，负载测试，局部故障 灵活的插件API 支持多线程测试 TestNG注解列表 注解 描述 @BeforeSuite 在该套件的所有测试都运行在注释的方法之前，仅运行一次 @AfterSuite 在该套件的所有测试都运行在注释方法之后，仅运行一次 @BeforeClass 在调用当前类的第一个测试方法之前运行，注释方法仅运行一次 @AfterClass 在调用当前类的第一个测试方法之后运行，注释方法仅运行一次 @BeforeTest 注释的方法将在属于\\标签内的类的所有测试方法运行之前运行 @AfterTest 注释的方法将在属于\\标签内的类的所有测试方法运行之后运行 @BeforeGroups 配置方法将在之前运行组列表。此方法保证在调用属于这些组中的任何一个的第一个测试方法之前不久运行 @AfterGroups 配置方法将在之后运行组列表。该方法保证在调用属于任何这些组的最后一个测试方法之后不久运行 @BeforeMethod 注释方法将在每个测试方法之前运行 @AfterMethod 注释方法将在每个测试方法之后运行 @DataProvider 标记一种方法来提供测试方法的数据。注释方法必须返回一个Object[][]，其中每个Object[]可以被分配给测试方法的参数列表。要从该DataProvider接收数据的@Test方法需要使用与此注释名称相等的dataProvider名称 @Factory 将一个方法标记为工厂，返回TestNG被用作测试类的对象。该方法必须返回Object[] @Listeners 定义测试类上的侦听器 @Parameters 描述如何将参数传递给@Test方法 @Test 将类或方法标记为测试的一部分 使用注解的好处： TestNG可以通过查找注解来识别它感兴趣的方法 可以将其他参数传递给注释 注释是强类型的，所以编译器会马上标记任何错误 测试类不再需要扩展任何东西 具体用法参见：https://www.yibai.com/testng","categories":[],"tags":[{"name":"TestNG笔记（易百教程）","slug":"TestNG笔记（易百教程）","permalink":"http://yoursite.com/tags/TestNG笔记（易百教程）/"}]},{"title":"JUnit","slug":"JUnit","date":"2018-02-09T12:59:13.000Z","updated":"2018-03-10T07:19:04.000Z","comments":true,"path":"2018/02/09/JUnit/","link":"","permalink":"http://yoursite.com/2018/02/09/JUnit/","excerpt":"关于JUnitJUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。JUnit促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 所谓单元测试是测试应用程序的功能是否能够按需要正常运行，并且确保是在开发人员的水平上，单元测试生成图片。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。","text":"关于JUnitJUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。JUnit促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 所谓单元测试是测试应用程序的功能是否能够按需要正常运行，并且确保是在开发人员的水平上，单元测试生成图片。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。 特点 JUnit是一个开放的资源框架，用于编写和运行测试。 提供注释来识别测试方法。 提供断言来测试预期结果。 提供测试运行来运行测试。 JUnit测试允许你编写代码更快，并能够提高质量。 JUnit测试可以自动运行并且检查自身结果并提供即时反馈。 JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。 JUnit测试框架 JUnit是一个回归测试框架，被开发者用于实施对应用程序的单元测试，加快程序编制速度，同时提高编码的质量。JUnit测试框架具有以下重要特性： 测试工具：是一整套固定的工具由于基线测试。测试工具的目的是为了确保测试能够在共享且固定的环境中运行，因此保证测试结果的可重复性。包括：在所有测试调用指令发起前的setUp()方法；在测试方法运行后的tearDown()方法。 测试套件：意味捆绑几个测试案例并且同时运行。在JUnit中，@RunWith和@Suite都被用作运行测试套件。 测试运行器：用于执行测试案例。 JUnit测试分类 包含一套断言方法的测试断言 包含规定运行多重测试工具的测试用例 包含收集测试用例结果的方法的测试结果 JUnit APIJUnit中的最重要的程序包是junit.framework。 类名 类的功能 Assert assert方法的集合 TestCase 一个定义了运行多重测试的固定装置 TestResult TestResult集合了执行测试样例的所有结果 TestSuite TestSuite是测试的集合 Assert类 方法 描述 void assertEquals(boolean expected,boolean actual) 检查两个变量或等式是否平衡 void assertFalse(boolean condition) 检查条件是假的 void assertNotNull(Object object) 检查对象不是空的 void assertNull(Object object) 检查对象是空的 void assertTrue(boolean condition) 检查条件为真 void fail() 在没有报告的情况下使测试不通过 void assertSame(boolean condition) 检查两个相关对象是否指向同一个对象 void assertNotSame(boolean condition) 检查两个相关对象是否不指向同一个对象 void assertArrayEquals(expectedArray,resultArray) 检查两个数组是否相等 TestCase 方法 描述 int countTestCases() 为被run(TestResult result)执行的测试案例计数 TestResult createResult() 创建一个默认的TestResult对象 String getName() 获取TestCase的名称 TestResult run() 一个运行这个测试的方便的方法，收集由TestResult对象产生的结果 void run(TestResult result) 在TestResult中运行测试案例并收集结果 void setName(String name) 设置TestCase的名称 void setUp() 创建固定装置，例如：打开一个网络连接 void tearDown() 拆除固定装置，例如：关闭一个网络连接 String toString() 返回测试案例的一个字符串表示 TestResult类 注释 注释 描述 @Test 这个注释说明依附在JUnit的public void方法可以作为一个测试案例 @Before 有些测试在运行前需要创造几个相似的对象。在public void方法加该注释是因为该方法需要在test方法前运行 @After 如果你将外部资源在Before方法中分配，那么你需要在测试运行后释放他们。在public void方法加该注释是因为该方法需要在test方法后运行 @BeforeClass 在public void方法加该注释是因为该方法需要在类中所有方法前运行 @AfterClass 它将会使方法在所有测试结束后执行。这个可以用来清理活动 @Ignore 这个注释是用来忽略有关不需要执行的测试的 具体用法参见：https://www.w3cschool.cn/junit","categories":[],"tags":[{"name":"JUnit笔记（W3Cschool）","slug":"JUnit笔记（W3Cschool）","permalink":"http://yoursite.com/tags/JUnit笔记（W3Cschool）/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2018-01-31T08:50:50.000Z","updated":"2018-02-01T05:19:40.000Z","comments":true,"path":"2018/01/31/Linux基础/","link":"","permalink":"http://yoursite.com/2018/01/31/Linux基础/","excerpt":"Linux文件系统概述文件系统具有以下特点： 文件系统是由文件及目录组成 每个目录或者文件在磁盘上都对应了一定的存储空间 每个目录或者文件都可以被复制或者删除，除了一些只读的文件系统外 如果有多个存储实体，比如磁盘、U盘，那么，它们将对应多个并列的、不同的文件系统 文件系统有不同的类型","text":"Linux文件系统概述文件系统具有以下特点： 文件系统是由文件及目录组成 每个目录或者文件在磁盘上都对应了一定的存储空间 每个目录或者文件都可以被复制或者删除，除了一些只读的文件系统外 如果有多个存储实体，比如磁盘、U盘，那么，它们将对应多个并列的、不同的文件系统 文件系统有不同的类型 目录名 描述 bin 用户级二进制工具 boot Linux内核镜像文件，由bootloader程序读取并装载 dev 各种系统硬件设备 etc 系统配置文件及其他配置文件 home 用户工作目录 lib 系统运行时所需的各种库文件 opt 操作系统附带的一些应用程序 proc 内核及进程所虚拟的系统文件 root 管理员工作目录 sbin 与bin的区别在于，该目录下的二进制工具程序仅用于管理员 sys 一般是驱动程序对应的虚拟文件系统 usr 管理安装的、所有用户都可以访问的应用程序 var 系统运行时所产生的一些调试信息文件或者相关统计文件 注：Linux系统根目录结构 Linux启动过程通用系统的启动过程：开机并执行bootloader程序—&gt;操作系统内核初始化—&gt;执行第一个应用程序 第一步是开机，开机是给系统供电，此时硬件电路会产生一个确定的复位时序，保证CPU是最后一个被复位的器件。当正确完成复位后，CPU开始执行第一条指令，该指令所在的内存地址是固定的，这由CPU的制造者指定，这个固定地址所保存的程序往往被称为“引导程序”（Bootloader），因为其作用是装载真正的用户程序。不同的CPU会提供不同的装载方式，有的是通过普通的并口存储器，有的则是通过SD卡、RS232接口等。装载过程必须提供以下信息： 从哪里读取用户程序？ 用户程序的长度是多少？ 装载完用户程序后，应该跳转到哪里，即用户程序的执行入口在哪里？ 第二步是执行内核程序，这里的内核程序是指上一步中的用户程序。内核程序初始化时执行的操作包括，初始化各种硬件，包括内存、网络接口、显示器、输入设备，然后建立各种内部数据结构，这些数据结构将用于多线程调度及内存的管理等 第三步是运行Home程序，Home程序是指通过改程序可以很方便地启动其他应用程序，传统的Linux系统启动后，第一个运行程序一般是一个Terminal，尽管它表面上就像一个Dos界面，但它也可以被称为Home程序，因为Home程序设计的目的就是提供一个入口，用户可以通过该入口启动其他应用程序 ##常用Linux命令 man：当我们不清楚某个Linux命令的作用和用法时，可以使用man command进行查询，command为具体的命令名称 find：find命令用于查找某个文件或文件夹，比如find . -name &quot;*.java&quot;该命令用于查找当前目录下扩展名为Java的所有文件find后面的”点“代表当前目录，*为通配符，代表任何名称 grep：为正则表达式匹配命令，该命令用于字符串匹配。例：grep &quot;Activity&quot; hello.java。grep和find的区别在于：find用于查找目录或文件，而grep用于查找指定的字符串，并且字符串可以由正则表达式描述 xargs：xargs并不是一个命令，而是一个标识，代表了上一个命令的执行结果，并作为下一个命令的参数。Linux命令可以流水线执行，也称”多管道“执行，即两个命令用”|“分隔符隔开。比如，想查找当前目录下文件名中包含”oa“的所有文件，可以使用如下命令：ls | xargs grep &quot;oa&quot; cat：cat命令用于连接文件内容并在Terminal中输出文件内容，该命令后面如果只有一个文件名称，则仅输出该文件内容 sudo：用在命令前，含义是使用管理员权限执行后续的命令，因为有些命令要求有管理员权限 chmod：在Linux系统中，文件的访问者被划分为三类，并针对这三类用户指定不同的访问权限。这三类访问者是：user(u)，用户自身，即创建该文件的用户；group(g)，用户所在组，即与创建在一个组里面的用户；other(o)，其他用户。chmod命令就是用于设置这三类访问者对某文件的访问权限。访问权限分为读(r)权限、写(w)权限、执行(x)权限，文件类型不同，”执行“的含义不同。可以通过ls -l命令查看文件的访问权限，Linux系统使用10位(bit)数据表示访问的权限。bit 0：使用-或者d表示，前者表示这是一个文件，后者表示这是一个目录；bit 1~bit 3：用户自身(user)对该文件的访问权限；bit 4~bit 6：用户组(group)对该文件的访问权限；bit 7~bit 9：其他用户(other)对该文件的访问权限。例：某个文件的属性为-rwxrwx---，这表示它是个文件，用户对文件拥有读取、写入、执行权限，用户组对该文件也拥有读取、写入、执行权限，而其他用户则不能读取、不能写入、不能执行。修改文件权限chmod u+x copy.sh命令中u+x的含义是给user添加执行(x)的权限，类似的也可以是o+x、o+rw、g+rwx等，可以用a代表所有用户。对于某些Linux系统，chmod不识别r、w、x这样的参数，而只能使用8进制数字值来表示，chmod 777 copy.sh其中777为8进制的数，对应二进制数据为111 111 111，这就分别代表了u、g、o三类用户的访问权限 ps，kill：ps用于列出当前运行的所有进程，kill用于杀死某个进程。这两个命令多用于系统调试，比如，可以先用ps列出所有进程，从输出信息中得到每个进程的id值，即pid，然后调用kill -9 pid就可以杀死指定pid对应的进程。-9是一个参数，具体可用man kill查看 export：该命令用于将某个变量值的作用域设为全局范围 cd 、ls、cd .. Shell脚本备忘凡是需要按一定的次序执行多个Linux命令的场合都可以使用脚本来完成 1、获取输入 输入包含三种：第一种是执行脚本时用户的输入；第二种是将前一个脚本的输出作为该脚本的输入；第三种是脚本函数的参数。用户的输入可以用$n表示，n为1~9自然数，分别代表输入中的第n个参数 123456789#!/bin/bashecho $1echo $2echo $3执行该脚本，输出为：$./me i love youiloveyou 2、变量定义 在Bash脚本中的变量没有类型，所有的变量都是字符串。变量不要单独定义，可直接赋值，赋值语句中不能有空格。引用变量时只需在变量前加一个$符号即可。为了避免混淆，常常使用双引号包含要引用的变量 12345678#!/bin/bashA=bAll=allecho &quot;$A&quot;llecho $All执行后输出为：bllall 3、条件判断 条件判断主要是判断两个字符串 是否相等、两个数字是否相等。其语法格式如下： 12345678#!/bin/bashif [ &quot;$1&quot; = &quot;normal&quot; ]then echo &quot;this is normal case&quot;elif [ -z &quot;$1&quot; ]then echo &quot;no input,ignal...&quot;fi 该段代码判断用户输入的第一个参数，如果其值等于”normal“字符串，则显示”this is normal case“，如果第一个参数为空，则显示”no input，ignal…“ 条件判断语法中要注意： 每个if语句后面的执行部分必须跟在then后面 多个判断分支可以使用elif语句 条件语句必须使用fi结束 条件语句中”[”符号后面必须要有一个空格 Bash脚本的比较运算符 操作符 返回true的条件 操作数的个数 -n 操作数的长度不为零 1 -z 操作数的长度为零 1 -d 操作数对应一个目录 1 -f 操作数对应一个文件 1 -eq 操作数为整数，并且相等 2 -neq 操作数为整数，但不相等，与-eq相反 2 = 操作数为字符串，并且相等 2 != 操作数为字符串，但不相等，与=相反 2 -lt 小于（less than），操作数为整数 2 -gt 大于（great than），操作数为整数 2 -ge 大于等于（great equal），操作数为整数 2 -le 小于等于（less equal），操作数为整数 2 4、while []…do…done语句 该语句类似于C语言中的do…while语句，举例如下： 12345678910111213141516171819202122#!/bin/bashecho &quot;please use add or delete or exit&quot;ACTION=&quot;default&quot;while [ -n $ACTION ]do read ACTION case $ACTION in add) echo &quot;add somebody&quot; ;; delete) echo &quot;delete somebody&quot; ;; exit) echo &quot;complete&quot; break ;; *) echo &quot;invalide action,please re-enter&quot; ;; esacdone 以上脚本的作用是根据用户输入的参数，执行不同的内容。read是一个Linux命令，用于提示用户输入并以按回车键（LF）结束输入。输入的内容保存到变量ACTION中，接下来的case语句根据ACTION的值，执行不同的动作，esac也是一个Linux命令，这里可以理解为case语句的结束标识。要退出整个while循环，可以使用break语句，done语句是整个while语句的结束标识 5、for循环 Bash中的for循环类似于Java中的foreach语句，for一般与in联合使用，用于从某个集合中逐个取出元素并对其进行操作 1234567#!/bin/bashfor X in `ls`do echo `basename $X` echo `dirname $X`doneuname 在这段代码中，in集合的来源是Linux ls命令，即当前目录下的所有文件。需要注意的是如果要把Linux的某个命令的输出作为集合，或者作为其他命令的输入，需要把该命令包含在“`”符号之中，该符号是键盘上！符号左边的那个按键；如果仅仅是执行某个Linux命令则不需要上述符号。代码中basename和dirname命令用于显示一个字符串中的路径和文件名称，例如/user/local/lib/lib.so对应的dirname是/user/local/lib，对应的basename是lib.so。其本身并不去检测该文件是否真正存在于磁盘上，而仅仅是针对字符串的操作 6、函数 1234567891011121314151617181920212223242526#!/bin/bashstrcat()&#123; OUT=&quot;$1&quot;&quot; &quot;&quot;$2&quot; return 0&#125;strcat2()&#123; echo &quot;$1&quot;&quot; &quot;&quot;$2&quot; return 3&#125;A=&quot;bird&quot;B=&quot;mouse&quot;OUT=&quot;&quot;strcat $A $Becho $OUTOUT2=`strcat2 $A $B`echo $?echo $OUT2运行该脚本的输出为：bird mouse3bird mouse 脚本中的函数具有以下特点： 定义函数时，不需要定义参数，在函数实体中可以直接使用$1代表输入的第n个参数 函数可以使用return关键字返回整数数值，但return返回数值并不能通过等号赋值给函数的调用者，函数必须使用echo命令返回内容给调用者 调用函数时，如果要获得函数的输出，并且赋值给某个变量，则函数的执行必须包含在“`”符号之间 如果要获得函数的返回值而不是输出，即函数中return关键字后面的数值则可以使用$?符号。该符号代表了上一个命令的返回值，所谓的上一个命令可以是一个函数，也可以是一个Linux命令，在一般情况下，return关键字返回的数值应该用于表明脚本的执行状态结果 7、常用内置符号常量 内置符号常量 符号值 意义 $@ 代表全部参数，比如test a b c，此处为“a“ ”b“ ”c”，展开后为三个字符串 $* 全部参数，比如test a b c，此处为“a b c”，展开后为一个字符串 $# 参数的个数，比如test a b c，此处是3 \\$? 上一个命令的返回结果，如果上一个命令是脚本函数，则对应函数中return的数值，比如ls\\ echo”$?”，结果为0 $$ 当前命令所在的进程号（PID） ##Make脚本备忘 Linux系统中包含一个Make脚本的解释器，它可以读取Make脚本的内容，并执行之，Make脚本多用于自动编译过程。Make脚本的基本语法如下： 12目标(target):条件(prerequest)(Tab键)命令 在该语法中，目标可以是任意一个字符串名称，也可以是具体文件的名称，条件可以是其他目标的名称，也可以是具体文件的名称。执行Make脚本时，Make解释器会检查目标和条件中包含的文件时间戳是否相同，如果不同，解释器就会执行Tab键后面的命令，命令可以使任何可执行程序。 自动编译的基本原理是将目标文件作为“目标”，将源文件作为“条件”，因此，当源文件被修改过后，目标文件的时间戳就会早于源文件，于是Make解释器便会自动执行指定的“命令”。此时可以将执行编译的命令作为这里的“命令”，从而达到自动编译的目的。 1234567891011121314#Filename Makefile#this file is used for show how to use makefile$(info start working)hello:hello.c echo &quot;nothing&quot;hello.bin:hello.c @echo &quot;now make hello.bin&quot; gcc hello.c -o hello.bin.PHONY:hehe:hello.c @echo &quot;now make he&quot; gcc hello.c -o hello.bin 该段代码有以下特点： #是注释符，可以用在代码中任何地方 第三行中$是函数调用符号，info是一个函数名称，作用是输出一段信息。类似的信息输出函数还包括warning、error两个函数，不过error函数执行后会终止执行并退出 目标定义前不能加任何空格，而命令行前必须以Tab键开始 .PHONY关键字用于声明一个目标，被.PHONY声明的目标将总是执行其指定的命令，而如果不声明的话，则仅当目标后面的条件变动后才执行 命令前面的@符号的作用是，不显示被执行的命令。因为在默认情况下，Make解释器在执行命令时会打印出执行的命令 对于hello.bin目标，该目标本身是一个文件，其依赖的文件是hello.c文件。因此当hello.c文件被修改后，将会执行gcc命令重新对该c文件编译，并输出hello.bin文件 要执行以上脚本，可运行make -f Makefile hello，在该命令中，-f参数用于指定要执行的脚本文件名称。如果不指定文件名称，则解释器会自动从当前目录下寻找名称为Makefile的脚本文件，如果找不到，则执行失败。hello代表要执行的具体目标，因为一个脚本文件中可能包含多个目标的定义。如果不指定目标，则解释器默认执行脚本中定义的第一个目标。指定的目标不同，执行的命令也将不同 对于hello和he目标，因为它们不是文件名称，所以每次Make该目标时，都会执行指定的命令；而对于hello.bin，由于它是一个文件，因此，只有当hello.c被修改后才会执行编译命令 对于hello和he目标，由于这两个目标不是文件，所以其条件中所指定的hello.c文件其实没有什么意义，其对应的命令总是会被执行 1、变量的定义与赋值 Makefile中的变量不需要单独定义，可直接赋值 Make脚本中的变量赋值符号 赋值符号 意义 := 简单展开型，它在该Makefile被解析时就立即展开并赋值 = 递归展开型，该赋值方式只有当所定义的变量在使用的时候才展开 ?= 条件赋值，只有当该变量还没有值时才赋值 += 附加赋值 2、条件控制语句 Make脚本的条件控制可分为两类：一类是在解释器解析脚本文件时处理，另一类是在执行脚本时处理 第一类条件控制语句的语法模型 123456789if-condition text if the condition is trueendif或者if-condition text if the condition is trueelse text if the condition id falseendif 其中condition只能进行两种判断，一种是判断表达式是否相等，另一种是判断表达式是否被定义，如下： ifdef var，判断变量var是否被定义过。如前所述，脚本并不需要单独定义，只要给该变量赋值过，那么它就被定义了 ifndef var，与ifdef相反，判断变量var是否还没有被定义 ifeq test，判断表达式test是否相等，表达式可写“a” “b“ 或（a，b） ifneq test，与ifeq相反 3、宏（函数）定义 Make脚本中的函数，按被调用的方式可分为三类 内置函数，即Make解释器内部定义好的函数，在任何脚本文件中可直接调用，调用的格式为：$(filename,param...)fname是函数的名称，param是参数，多个参数用逗号分隔 用户定义的、带参数的函数，使用define关键字进行定义，调用的格式为：$(call fname,param)call是调用的关键字，fname代表函数名称，param是函数参数，多个参数使用逗号分隔 用户定义的、不带参数的函数，该类函数也称之为宏，其调用的格式为：$(fname)即不使用call关键字，也不包含参数 4、内置符号和变量 内置符号 符号 意义 $@ target的名称 $* 和$@类似，只是不包含target的后缀 $^ 所有的先决条件名称，以空格分隔，如果先决条件中有重复，则自动去除重复 \\$? 有更新的先决条件列表，比如，有4个先决条件，其中有3个刚刚被修改过，则$?就代表刚刚被修改过的先决条件，以空格分隔 \\$+ 所有的先决条件，和$^类似，只是\\$+包含了重复的先决条件，而\\$^会自动去除重复的先决条件 $&lt; 第一个先决条件名称 内置变量 变量名称 意义 MAKE_VERSION make版本 CURDIR 执行make时的目录 MAKEFILE_LIST 本次make命令执行时，所有被包含的makefile列表 VARIABLE 所有的变量列表 5、模板目标 123456789101112.PHONY: testtest: f1.o f2.o main.o gcc -o main.bin fi.o f2.o main.of1.o: f1.c gcc f1.c f1.of2.o: f2.c gcc f2.c -c f2.o main.o: main.c gcc main.c -c main.o 使用模板目标后： 1234567OBJ = f1.o f2.o main.o.PHONY: testtest: ($OBJ) gcc $(OBJ) -o main.bin%.o: %.c gcc -c -o $@ $&lt; %.o就是模板目标，百分号是模板通配符，意思是所有.o文件。除了通配符外，代码中另外一个关键是使用符号常量$@和\\$^，前者代表目标名称，后者代表第一个先决条件的名称 6、目标特定的变量赋值 12345678CFLAGS = -c.PHONY: tar1tar1 : gcc $(CFLAGS) main.ctar2 : CFLAGS = tar2 : gcc $(CFLAGS) main.c CFLAGS被赋值为-c，其值在整个脚本文件范围内都是有效的。比如当Make tar1时，就会执行gcc -c main.c，但是在tar2目标中，我们希望能够执行gcc main.c，因此可以在tar2目标中对CFLAGS重新赋值，该赋值仅在tar2目标的命令中有效。这就是所谓的”目标特定“变量赋值，因为该赋值仅针对于该目标","categories":[],"tags":[{"name":"Linux基础（《Android内核剖析》）","slug":"Linux基础（《Android内核剖析》）","permalink":"http://yoursite.com/tags/Linux基础（《Android内核剖析》）/"}]},{"title":"Maven","slug":"Maven","date":"2018-01-21T02:09:49.000Z","updated":"2018-03-08T02:07:18.000Z","comments":true,"path":"2018/01/21/Maven/","link":"","permalink":"http://yoursite.com/2018/01/21/Maven/","excerpt":"Maven定义Maven是一个跨平台的项目管理工具。Maven主要服务基于Java平台的项目构建，依赖管理，项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。","text":"Maven定义Maven是一个跨平台的项目管理工具。Maven主要服务基于Java平台的项目构建，依赖管理，项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。 Maven作为一个构建工具，它不仅仅能帮我们自动化构建，它还能够抽象构建过程，提供构建任务实现，它跨平台，意味着不管是在windows上，还是在Linux或者Mac上，都可以使用同样的命令，构建同样的项目，得到同样的结果，对外提供了一致的操作接口，这一切足以使它成为优秀的，流行的构建工具。 Maven不仅仅是构建工具，它还是一个依赖管理工具，还是一个项目信息管理工具。它提供了中央仓库，并能帮你自动下载构件。在开源的年代里，几乎任何一个Java应用都会借用一大堆第三方的开源类库，这些类库都通过依赖的方式引入到项目中来。它通过一个坐标系统准确定位每一个构件（Artifact），也就是通过一组坐标，Maven能够找到任何一个Java类库如jar文件，Maven给这个类库世界引入经纬，带来的秩序，于是我们就能够借助它帮助我们有序的管理依赖，轻松的解决那些繁杂的以来问题。通过Maven自动生成的站点和一些已有的插件，我们还能够轻松获得项目文档，测试报告，静态分析报告，源码版本日志报告，等等非常具有价值的项目信息。Maven还给全世界Java开发者提供了一个免费的中央仓库，我们可以找到几乎任何的流行开源类库。 编写POM就像Make的Makefile，Ant的build.xml，Maven项目的核心是pom.xml。POM的意思是项目对象模型（Project Object Model），在这个模型中我们定义项目的基本信息，描述项目如何构建，声明项目依赖，等等。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.maven-book&lt;/groupId&gt; &lt;artifactId&gt;ch-hello-world&lt;/artifaceId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Hello World Project&lt;/name&gt;&lt;/project&gt; 代码的第一行是XML头，指定了该xml文档的版本和编码方式。紧接着是project元素，project是所有pom.xml的根元素。注意该project根元素还声明了一些POM相关的命名空间及xsd元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具如IDE中的XML编辑器帮助我们快速编辑POM。 根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven2来说，它只能是4.0.0. 这段代码中最重要的是groupId，artifactId和version三行。这三个元素定义了一个项目基本的坐标，就像我们的身份证号码一样，在Maven的世界，任何的jar，pom或者war都是基于这些基本的坐标进行区分的。 groupId定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，例如com.googlecode.myapp version指定了项目当前的版本，当前这个Hello World项目的版本是1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还出于开发中，是不稳定的版本。 最后一个name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每一个POM声明name，以方便信息交流。 Maven能让项目对象模型最大程度的与实际代码相独立，这在很大程度上避免了Java代码和POM代码相互影响。比如当项目需要升级版本的时候，只需要修改POM，不需要修改Java代码；而在POM稳定后，日常的Java代码开发工作基本不会涉及到POM的修改。 编写主代码关于Java主代码需要注意两点，首先，应该把项目主代码放到src/main/java/目录下，这是Maven的约定，遵循了该约定，就无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，Java类的包名与之前在POM中定义的groupId和artifactId相吻合，一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，虽然这不是必须的，但显然这样做更加清晰，更加符合逻辑，也方便搜索构件或者Java类。 编写测试代码为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录，Maven项目中默认的主代码目录是src/main/java，对应的，Maven项目中默认的测试代码目录是src/test/java，因此，在编写测试用例之前，我们要先创建该目录。 在Java世界中，JUnit是事实上的单元测试标准。修改项目的POM，添加JUnit依赖。 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifact&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在XML代码中添加了dependencise元素，该元素下可以包含多个dependency元素声明项目的依赖。添加的JUnit依赖groupId是junit，artifactId是junit，version是4.7。有了这段声明，Maven就能够自动下载junit-4.7.jar。scope元素为依赖范围，当依赖范围是test的时候，表示该依赖只对测试有效。如果不声明依赖范围，默认值是compile，表示该依赖对主代码和测试代码都有效。 Maven2常用命令介绍建立项目（使用Archetype骨架） 建立项目的命令为：mvn archetype:generate -DarchetypeArtifactId=[项目类型] -DgroupId=[组识别] -DartifactId=[项目名称（包名称）] -Dversion=[版本] -Dpackage=[包] 项目类型（archetypeArtifactId）可以是下列选项 1.maven-archetype-j2ee-simple(J2EE项目) 2.maven-archetype-portlet(门户) 3.maven-archetype-quickstart(一般Java project) 4.maven-archetype-site(复杂站点) 5.maven-archetype-site-simple(简单站点) 6.maven-archetype-webapp(Java Web站点) groupId 用于项目的分组 artifactId 项目的名称，也就是包名称 version 版本 package 主要设定目录的层次 编译项目 #mvn compile 执行单元测试 #mvn test 在执行单元测试前，首先会执行编译动作 测试报告放在target\\site\\surefire-reports下 生成文档 #mvn javadoc:javadoc 生成的文档会在target\\site\\apidocs下 生成项目站点 #mvn site:site 生成站点放在\\target\\site下 清楚项目生成文件 #mvn clean:clean 打包文件 #mvn package 生成的包文件在target目录下（默认是jar文件） 将项目安装到本地仓库 #mvn install 发布项目 #mvn deploy 修改pom.xml调整编译参数 编译参数主要通过使用设定maven-compile-plugin来实现 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如上，可以设定编译使用UTF-8编码，源码为JDK1.5的版本，目标也为JDK1.5的版本。 设定使用UTF-8编码 除了编译外，还有资源文件、javadoc等都需要告诉maven使用UTF-8编码，可以设定如下两个插件 123456789101112&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 添加TestNG的测试框架支持 由于自动生成的项目为使用JUnit的测试框架，要使用TestNG的测试框架需要调整一下项目的依赖关系，并且设定项目使用的TestNG配置文件。 首先需删除对于JUnit的依赖 然后加入如下内容 1234567&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;5.8&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 由于TestNG需要不同的包支持JDK15和JDK14，所以要特别指定\\属性。如果没有指定\\属性，maven会自动下载最新版本。\\属性设定了依赖项的使用范围，如果设定为test表示仅测试时使用，在打包时不会打包该文件。可以使用插件maven-surefire-plugin设定testNG的配置文件位置，如下： 12345678&lt;plugin&gt; &lt;artifactId&gt;maven-surefile-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;suiteXmlFiles&gt; &lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt; &lt;/suiteXmlFiles&gt; &lt;/configuration&gt;&lt;/plugin&gt; 表示使用testng.xml作为testNG的配置文件","categories":[],"tags":[{"name":"Maven笔记","slug":"Maven笔记","permalink":"http://yoursite.com/tags/Maven笔记/"}]},{"title":"java Exception","slug":"java-Exception","date":"2018-01-19T02:15:27.000Z","updated":"2018-01-19T05:10:16.000Z","comments":true,"path":"2018/01/19/java-Exception/","link":"","permalink":"http://yoursite.com/2018/01/19/java-Exception/","excerpt":"java异常体系架构：","text":"java异常体系架构： Error是程序无法处理的错误，它是由JVM产生和抛出的。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止 Exception是程序本身可以处理的异常，这种异常分两大类： ​ 运行时异常是不检查异常，一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 ​ 非运行时异常从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能通过编译 异常处理throw ​ throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，就是打印异常消息和堆栈信息 ​ 用法：throw new Exception(“方法中存在Exception”) throws ​ throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用无力处理该异常的时候，也应该继续抛出 ​ 假设f方法抛出了A异常，则f方法有两种方式来处理A异常 ​ 1.throwsA ​ 谁调用f方法，谁处理A异常，f方法本身不处理A异常 ​ 2.try{……}catch(){……} ​ f方法本身自己来处理A异常 ​ 要抛出的异常必须是Throwable的子类 ​ throws A不表示f方法一定会抛出A类异常 ​ throws A不表示调用f方法时，必须得对A异常进行捕捉 ​ 假设A是RuntimeException的子类异常 ​ 由于RuntimeException的子类异常可以处理也可以不处理，所以编译器允许 你调用f方法时，对f方法抛出的RuntimeException子类异常不进行处理 ​ 建议： ​ 1.对throws出的所有异常进行处理 ​ 2.如果一个方法内部已经对A异常进行了处理，则就不要再throws A try catch finally ​ 1.try catch finally三个语句块均不能单独使用，try……catch、try……finally、try……catch……finally ​ 2.try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能互相访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外部 ​ 3.多个catch块的时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行 ​ 4.先catch子类异常再catch父类异常 ​ finally的作用： ​ 1.无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛出的异常类型一致，finally中的代码一定会得到执行 ​ 2.finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，能对程序的状态做统一的管理 ​ 3.通常在finally语句中可以进行资源的清除工作，如关闭打开的文件、删除临时文件等","categories":[],"tags":[{"name":"java异常","slug":"java异常","permalink":"http://yoursite.com/tags/java异常/"}]},{"title":"JsonNote","slug":"JsonNote","date":"2017-12-20T08:03:55.000Z","updated":"2018-01-20T09:19:32.000Z","comments":true,"path":"2017/12/20/JsonNote/","link":"","permalink":"http://yoursite.com/2017/12/20/JsonNote/","excerpt":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组","text":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 Json名称/值对 ：Json数据的书写格式：名称/值对（包括字段名称（在双引号中），后面写一个冒号，然后是值）”name” : “张三” Json值可以为： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true或false） 数组（在中括号中）：可以包含多个对象 12345&#123;&quot;sites&quot;:[ &#123;&quot;name&quot; : &quot;百度&quot; , &quot;url&quot; : &quot;www.baidu.com&quot;&#125;, &#123;&quot;name&quot; : &quot;谷歌&quot; , &quot;url&quot; : &quot;www.google.com&quot;&#125;, &#123;&quot;name&quot; : &quot;微博&quot; , &quot;url&quot; : &quot;www.weibo.com&quot;&#125;]&#125; Json使用JavaScript语法，和JavaScript创建对象数组，访问数组项，修改数据一样 Json文件的文件类型是：.json Json文件的MIME类型是：application/json Json对象 ： 对象语法：{“name” : “baidu” , “alexa” : 10000 , “site” : null} Json对象使用在大括号({})中书写 对象可以包含多个key/value(键值对) key必须是字符串，value可以是合法的Json数据类型(字符串，数字，对象，数组，布尔值或null) key和value中使用冒号(:)分隔 每个key/value对使用逗号(,)分隔 访问对象值：可以使用(.)来访问对象值，也可以使用([])来访问对象值 1234var myObj,x;myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; : 10000 , &quot;site&quot; : null&#125;;x = myObj.name;x = myObj[&quot;name&quot;]; 循环对象：可以使用(for-in)来循环对象的属性，在for-in循环对象的属性时，使用中括号([])来访问属性的值 1234567var myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; = 10000 , &quot;site&quot; = null&#125;;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;&lt;br&gt;&quot;;&#125;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象：Json对象中可以包含另外一个Json对象，可以使用(.)或([])来访问嵌套的Json对象 1234567891011myObj = &#123; &quot;name&quot; : &quot;baidu&quot;, &quot;alexa&quot; : 10000, &quot;sites&quot; : &#123; &quot;site1&quot; : &quot;www.baidu.com&quot;, &quot;site2&quot; : &quot;mmm.baidu.com&quot;, &quot;site3&quot; : &quot;nnn.baidu.com&quot; &#125;&#125;;x = myObj.sites.site1;x = myObj.sites[&quot;site1&quot;]; 修改值：可以使用(.)或者([])来修改Json对象的值 删除对象属性：可以使用delete关键字来删除Json对象的属性delete myObj.sites.site1 Json数组 ： Json中数组值必须是合法的Json数据类型，JavaScript中，数组值可以是Json数据类型，也可以是JavaScript的表达式，包括函数，日期和undefined Json对象中的数组：对象属性的值可以是一个数组；可以使用索引值来访问数组 循环数组：可以使用(for-in)来访问数组，也可以使用for循环 123for(i in myObj.sites)&#123; x += myObj.sites[i] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象中的数组：可以使用两个for-in或for循环来访问 修改数组值：可以使用索引值来修改数组值 删除数组元素：可以使用delete关键字来删除数组元素 JSON.parse() Json通常用于与服务器端交换数据，在接收服务器数据时一般是字符串，可以使用JSON.parse()方法将数据转换为JavaScript对象 语法：JSON.parse(text[,reviver]) 参数说明：text：必需，一个有效的字符串；reviver：可选，一个转换结果的函数，将为对象的每个成员调用此函数 从服务器端接收Json数据：可以使用Ajax从服务器请求Json数据，并解析为JavaScript对象 异常：解析数据：Json不能存储Date对象，如果需要存储，需要将其转换为字符串，之后再将字符串转换为Date对象 123456789101112var text = &apos;&#123; &quot;name&quot; : &quot;baidu&quot; , &quot;initDate&quot; : &quot;2000-01-12&quot; , &quot;site&quot; : www.baidu.com&quot; &#125;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;日期:&quot; + obj.initDate;//也可以启用reviver参数var obj = JSON.parse(text,function(key,value)&#123; if(key == &quot;initDate&quot;)&#123; return new Date(value); &#125;else&#123; return value; &#125;&#125;); JSON.stringify() 在向服务器端发送数据时一般是字符串，可以使用JSON.stringify()方法将JavaScript对象转换成字符串 语法：JSON.stringify(value[,replacer[,space]]) 参数说明： value：必需，一个有效的Json字符串 replacer：可选，用于转换结果的函数或数组。如果replacer为函数，则JSON.stringify将调用该函数，并传入每个成员的键和值，使用返回值而不是原始值，如果此函数返回undefined，则排除成员；根对象的键是一个空字符串：””。如果replacer是一个数组，则仅转换该数组中具有键值的成员，成员的转换顺序与键在数组中的顺序一样，当value参数也为数组时，将忽略replacer数组 space：可选，文本添加缩进、空格和换行符，如果space是一个数字，则返回文本在每个级别缩进指定数目的空格，如果space大于10，则文本缩进10个空格，也可以使用非数字：\\t Json使用 由于Json语法是JavaScript语法的自己，JavaScript函数eval()可用于将Json文本转换为JavaScript对象 eval()函数使用的是JavaScript编译器，可解析Json文本，然后生成JavaScript对象，必须把文本包围在括号中var obj = eval(&quot;(&quot;+txt+&quot;)&quot;);，eval()函数可编译并执行任何JavaScript代码，这隐藏了潜在的安全问题 JSONP Jsonp(JSON with Padding)是Json的一种“使用模式”，可以让网页从别的域名(网站)那获取资料，即跨域读取数据","categories":[],"tags":[{"name":"JsonNote","slug":"JsonNote","permalink":"http://yoursite.com/tags/JsonNote/"}]},{"title":"ajaxNote","slug":"ajaxNote","date":"2017-11-19T05:16:04.000Z","updated":"2018-01-20T07:59:54.000Z","comments":true,"path":"2017/11/19/ajaxNote/","link":"","permalink":"http://yoursite.com/2017/11/19/ajaxNote/","excerpt":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行","text":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行 XMLHttpRequest对象：用于在后台与服务器交换数据 ​ 创建XMLHttpRequest对象： ​ 语法：variable = new XMLHttpRequest(); ​ var xmlHttp; ​ if(window.XMLHttpRequest){ ​ xmlHttp = new XMLHttpRequest(); ​ } XMLHttpRequest请求：向服务器发送请求：open(),send() ​ xmlHttp.open(method,url,async)规定请求的类型、URL以及是否异步处理请求 ​ method：请求的类型：GET或POST ​ url：文件在服务器上的位置 ​ async：true（异步）或false（同步） ​ xmlHttp.send(string)将请求发送到服务器 ​ string：仅用于POST请求 ​ GET还是POST？ ​ 与POST相比，GET更简单也更快，并且在大部分情况下都能用。然而，在以下情况下请使用POST请求： ​ 1.无法使用缓存文件（更新服务器上的文件或数据库） ​ 2.向服务器发送大量数据（POST请求没有数据量限制） ​ 3.发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 ​ 如果希望通过GET方法发送信息，请向URL添加信息 ​ xmlHttp.open(&#39;GET&#39;,&#39;url?name=name&amp;pas=pas&#39;,true) ​ xmlHttp.send() ​ 如果希望像HTML表单那样POST数据，使用setRequestHeader()来添加http头部，然后在send()方法中规定要发送的数据 ​ xmlHttp.setRequestHeader(header,value)向请求添加http头 ​ header：规定头的名称 ​ value：规定头的值 ​ xmlHttp.open(&#39;POST&#39;,&#39;url&#39;,true); ​ xmlHttp.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;); ​ xmlHttp.send(&#39;name=name&amp;pas=pas&#39;); ​ 通过Ajax，JavaScript无需等待服务器的响应，而是在等待服务器响应时执行其他脚本，当响应就绪后进行处理。 XMLHttpRequest响应 ​ 如需要获得来自服务器的响应，使用XMLHttpRequest对象的responseText或responseXML属性 ​ responseText属性：返回字符串形式的响应数据 ​ responseXML属性：返回XML形式的响应数据 XMLHttpRequest readyState ​ onreadystatechange事件： ​ 当请求被发送到服务器时，我们需要执行一些基于响应的任务 ​ 每当readyState改变时，就会触发onreadystatechange事件 ​ readyState属性存有XMLHttpRequest的状态信息 ​ XMLHttpRequest对象的三个重要属性： ​ 1.onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用这个函数 ​ 2.readyState 存有XMLHttpRequest的状态 ​ 0：请求未初始化 ​ 1：服务器连接已建立 ​ 2：请求已接收 ​ 3：请求处理中 ​ 4：请求已完成，且响应已就绪 ​ 3.status 状态 200：’OK‘; 400：未找到页面 回调函数 ​ 回调函数是一种以参数形式传递给另一个函数的函数 ​","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Typora","slug":"Typora","date":"2017-11-12T02:54:04.000Z","updated":"2018-01-21T02:04:22.000Z","comments":true,"path":"2017/11/12/Typora/","link":"","permalink":"http://yoursite.com/2017/11/12/Typora/","excerpt":"##Markdown语法 下标 ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry:","text":"##Markdown语法 下标 ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry: 下划线 ：使用&lt;u&gt;Underline&lt;/u&gt; 产生下划线Underline 删除线 ：使用~~包裹的文本具有删除的样式删除文本 代码 ：使用`包裹的内容将会以代码样式显示 ​ pringtf() ​ 输入12345```javapublic Class HelloWorld&#123; System.out.println(&quot;Hello world!&quot;);&#125; 强调 ：使用两个*号包裹的内容会被强调 斜体 ：使用*和_包裹的内容会是斜体显示。 ​ 斜体 要显示号可以使用转义\\ 插入图片 ：可以通过拖拉的方式加入图片 插入URL连接 ：使用尖括号包裹的url将产生一个连接，例如： 如果是标准的url，则会自动产生连接 目录列表Table of Contents ：输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容 水平分割线 ：使用*或者—，然后回车，来产生水平分割线 标注 ：可以对一个词语进行[^标注] [^标注]：这是一个标注 表格 ： 一 张 表 一 张 表 数学表达式块 ：输入两个美元符号，然后回车，就可以输入数学表达式块 任务列表 ：-[]吃饭创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者未完成 吃饭 []逛街 列表 ：输入+，-，*创建无序的列表，使用任意数字开头，创建有序列表。例如： 无 序 列 表 有 序 列 表 块引用 ：使用&gt;来插入块引用 这是一个块引用 标题 ：使用#表示一级标题，##表示二级标题，依次类推，共6个标题","categories":[],"tags":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://yoursite.com/tags/Markdown语法/"}]},{"title":"Regex","slug":"Regex","date":"2017-10-20T02:57:32.000Z","updated":"2018-01-20T04:43:50.000Z","comments":true,"path":"2017/10/20/Regex/","link":"","permalink":"http://yoursite.com/2017/10/20/Regex/","excerpt":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置","text":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置 使用正则表达式： *测试字符串内的模式（可以测试输入字符串，以查看字符串内是否出现电话模式或信用卡模式，这称为数据验证） *替换文本（可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它） *基于模式匹配从字符串中提取字符串（可以查找文档内或输入域内特定的文本） java.util.regex包主要包括以下三个类： 1.Pattern类：Pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法，要创建一个Pattern对象，必须先调用其公共静态编译方法，它返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数 2.Matcher类：Matcher对象是输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher类也没有公共构造方法。需要调用Pattern对象的matcher方法来获得一个Matcher对象 3.PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误 捕获组： 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建，捕获组是通过从左至右计算其开括号来编号。例：((A)(B(C)))有四个组 可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多少个捕获组。(group(0))它代表整个表达式，但不包括在groupCount的返回值中 正则表达式语法： 其他语言中双反斜杠表示：在正则表达式中插入一个普通的反斜杠。在java中双反斜杠表示：插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。所以java的转义需要双反斜杠，java表示一位数字的正则表达式是双反斜杠d，而表示反斜杠则是四条反斜线 字符 含义 \\ 将下一字符标记为特殊字符 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结束的位置 * 零次或多次匹配前面的字符或子表达式 + 一次或多次匹配前面的字符或子表达式 ? 零次或一次匹配前面的字符或子表达式 {n} n是非负整数，正好匹配n次 {n,} n是非负整数，至少匹配n次 {n,m} n和m是非负整数，至少匹配n次，至多匹配m次 ? 在限定字符后，表示匹配模式是“非贪心模式”，即匹配尽可能短的字符串，默认是“贪心模式” . 匹配除了“\\r\\n”之外的任何单个字符 [xyz] 字符集，匹配包含的任一字符 [^xyz] 反字符集，匹配未包含的任一字符 [a-z] 字符范围，匹配指定范围内的任何字符 \\b 匹配一个字的边界，即字与空格间的位置 \\d 数字字符匹配，等效于[0-9] \\w 匹配任何字类字符，包括下划线，等效于[A-Za-z0-9] 具体类的方法参见JDK","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Git","slug":"Git","date":"2017-10-10T02:54:35.000Z","updated":"2018-01-20T03:41:10.000Z","comments":true,"path":"2017/10/10/Git/","link":"","permalink":"http://yoursite.com/2017/10/10/Git/","excerpt":"##Git Git是分布式版本控制系统Git命令","text":"##Git Git是分布式版本控制系统Git命令 git config --global user.name 设置用户名 git config --global user.email 设置用户邮箱 pwd 显示当前目录 git init 初始化git仓库 ls -ah 查看隐藏目录 git add &lt;文件名&gt; 添加文件 git commit -m &#39;本次提交说明&#39; 把文件提交到git仓库 可以同时提交多个文件，add多个，一次提交 git status 掌握仓库当前的状态 git diff 查看difference git log 查看历史纪录 显示从最近到最远的提交日志 git log --pretty=oneline 显示提交的版本号 git reset --hard HEAD^ 回退一次 HEAD^^ 回退两次…… git reset --hard 版本号 可以回到已经退过的最新版本 git reflog 记录每一次命令 HEAD指向的版本是当前的版本 cat &lt;文件名&gt; 查看文件中的内容 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 1.readme.txt自修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态 2.readme.txt已经添加到暂存区后，又做了修改，现在撤销修改就回到添加到暂存区后的状态 用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区 rm &lt;文件名&gt; 删除文件 确实要从版本库中删除该文件，那就用命令git rm 删掉，并且git commit git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” ssh-keygen -t rsa -C &#39;youremail@example.com&#39; 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的密钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以放心告诉任何人 git remote add origin git@github.com:Github账号/learngit.git 建立远程连接 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程 git push -u origin master git push origin master git checkout -b dev 创建dev分支 git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev git branch 命令查看当前分支 git checkout master 切换回master分支 git merge 命令用于合并指定分支到当前分支 git merge dev git branch -d dev 删除dev分支 git log --graph 命令可以看到分支合并图 git clone git@github.com:Github账号/learngit.git 从远程库克隆","categories":[],"tags":[{"name":"Git命令","slug":"Git命令","permalink":"http://yoursite.com/tags/Git命令/"}]}]}