{"pages":[],"posts":[{"title":"mysql-excel的小问题","slug":"mysql-excel的小问题","date":"2018-10-15T06:09:24.000Z","updated":"2018-10-15T06:12:16.000Z","comments":true,"path":"2018/10/15/mysql-excel的小问题/","link":"","permalink":"http://yoursite.com/2018/10/15/mysql-excel的小问题/","excerpt":"","text":"安装完MySQL后，每次打开Excel文件都会自动打开另外一个空白的Sheet。 使用管理员身份运行Excel，然后再开始-选项-加载项-COM加载项中取消掉MySQL for Excel就可。","categories":[],"tags":[{"name":"mysql,excel","slug":"mysql-excel","permalink":"http://yoursite.com/tags/mysql-excel/"}]},{"title":"设计模式","slug":"设计模式","date":"2018-08-23T02:40:41.000Z","updated":"2018-08-23T07:51:08.000Z","comments":true,"path":"2018/08/23/设计模式/","link":"","permalink":"http://yoursite.com/2018/08/23/设计模式/","excerpt":"设计模式是一套可以反复使用的经验，可以提高代码的可重用性，增强系统的可维护性","text":"设计模式是一套可以反复使用的经验，可以提高代码的可重用性，增强系统的可维护性 六大原则单一职责原则应该有且仅有一个原因引起类的变更 好处： 类的复杂性降低 可读性提高 可维护性、可拓展性提高 变更引起的风险降低 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化 里氏替换原则只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。反过来不行 采用里氏替换原则时，尽量避免子类的“个性” 依赖倒置原则面向接口编程 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 依赖注入的三种写法 构造函数传递依赖对象（创建私有对象，在构造函数上进行依赖注入） Setter方法传递依赖对象（创建私有对象，通过setXxx方法进行注入） 接口声明依赖对象（在方法参数上声明依赖并注入） 依赖倒置实现的几条原则 每个类尽量都有接口或抽象类，或者两者皆备 变量的表面类型尽量是接口或者抽象类（用接口声明，用接口的实现类实例化） 任何类都不应该从具体类派生 尽量不要覆写基类的方法 结合里氏替换原则使用 接口隔离原则建立单一接口，不要建立臃肿庞大的接口 接口要尽量小（根据接口隔离原则拆分接口时，首先必须满足单一职责原则） 接口要高内聚（提高接口、类、模块的处理能力，减少对外的交互） 定制服务（单独为一个个体提供优良的服务） 接口设计有限度 迪米特原则最少知识原则，一个对象应该对其他对象有最少的了解 类的低耦合 只和直接的朋友交流：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类 朋友间有适当距离：类尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中 谨慎使用Serializable 开闭原则对扩展开放，对修改关闭","categories":[],"tags":[{"name":"设计模式笔记","slug":"设计模式笔记","permalink":"http://yoursite.com/tags/设计模式笔记/"}]},{"title":"linuux笔记","slug":"linuux笔记","date":"2018-08-16T02:16:44.000Z","updated":"2018-08-20T02:24:50.000Z","comments":true,"path":"2018/08/16/linuux笔记/","link":"","permalink":"http://yoursite.com/2018/08/16/linuux笔记/","excerpt":"crtl+alt+F1/F2切换图形界面和文字界面 linux下区分大小写 date查看日期 cal [year] [ month]查看日历 bc 打开linux计算器，scale=number number表示小数点位数，quit离开","text":"crtl+alt+F1/F2切换图形界面和文字界面 linux下区分大小写 date查看日期 cal [year] [ month]查看日历 bc 打开linux计算器，scale=number number表示小数点位数，quit离开 [tab]（两下）接在一串指令的第一个字的后面（commend），则为命令补全 [tab]（两下）接在一串指令的第二个字的后面（文件），则为文件补全 若安装bash-completion软件，则在某些指令后面使用[tab]按键时，可以进行选项/参数的补全 ctrl+c中断目前程序（运行比较重要的指令，别急着用） crtl+d键盘输入结束，可以代替exit，要离开命令行，可以直接按下组合键代替exit shift + PageUP/PageDown，往前/往后翻页 指令 –help(date –help)查询指令用法和指令所具备的选项与参数 man+指令 可以查看指令更加详细的信息man date中DATE(1)DATE代表指令，(1)代表使用者在shell环境中可以操作的指令或可执行文件，可以通过man man指令来查看数字代表的内容，空格进行man环境的翻页，q退出man环境(man–manual操作说明) 1 – 使用者在shell环境中可以操作的指令或可执行文件 5 – 配置文件或者时某些文件的格式 8 – 系统管理员可用的管理指令 代号 内容说明 NAME 简短的指令、数据名称说明 SYNOPSIS 简短的指令下达语法介绍 OPTIONS 针对SYNOPSIS部分中，有列举的所有可用的选项说明 COMMANDS 当这个程序（软件）在执行的时候，可以在此程序中下达的指令 FILES 这个程序或数据所使用或参考或链接到的某些文件 SEE ALSO 可以参考的，跟这个指令或数据有相关的其他说明 EXAMPLE 一些可以参考的范例 Authors/Copyright 在man page环境下，/string – 向下搜寻string这个字符串；?string – 向上搜寻string这个字串；可以用n来继续下一个搜寻，N反向搜寻，q退出man环境 info类似man nano 文本编辑器（^ – ctrl；M – alt） crtl G：取得help crtl X：退出nano（Y保存，N不保存） ctrl O：保存 ctrl W：搜寻字符串 ctrl C：说明目前光标所在处的行数与列数等信息 ctrl _：可以直接输入行号，让光标快速移动到改行 sync：数据同步写入磁盘，将内存中尚未被更新的数据写入磁盘中（在关机和重新启动前需要记得多执行几次） 关机：shutdown/poweroff 重启：reboot Linux使用者(user)，群组(group)，其他人(others) ls -al列出当前目录下的所有文件，-al表示列出所有的文件详细的权限与属性（包含隐藏文件，就是文件名第一个字符为“.”的文件） 文件权限：由七部分组成 第一栏-rw-r–r– 文件类型权限。 第一个字符代表这个文件是目录文件或是文件等 d 代表目录 - 代表文件 l 代表链接文件 b 代表设备文件里面的可供存储的周边设备（可随机存期设备） c 代表设备文件里面的系列埠设备，键盘鼠标等（一次性读取设备） 接下来的字符三个一组，且均为rwx三个参数的组合，r代表可读，w代表可写，x代表可执行，如果没有权限为- 第一组为文件拥有者可具备的权限 第二组为加入此群组账号的权限 第三组为非本人且没有加入本群组的其他账号的权限 第二栏 1 链接数，表示有多少文件名链接到此节点 第三栏表示这个文件（或目录）的拥有着账号 第四栏表示这个文件的所属群组 第五栏表示这个文件的容量大小，默认单位Bytes 第六栏表示这个文件的创建日期或者是最近的修改日期（如果距离太久，仅显示年份） 第七栏表示文件的文件名（文件名前的”.”表示隐藏文件） chgrp：改变文件所属群组 chgrp [-R] 群组名 文件名（-R 递回，连同次目录下的所有文件都变更 chown：改变文件拥有者 chown [-R] 账号名称[:群组名称] 文件或目录 chmod：改变文件的权限，分别可以使用数字或符号进行权限的变更 数字，r：4，w：2，x：1，每种权限的计数需要累加，每三个一组，-rwxrwx—则是770，chmod [-R] xyz 文件或目录，xyz为770 符号，chmod |u g o a|+ - =| r w x|文件或目录，u(user) g(group) o(others) a(all)例：chmod u=rwx,go=rx 文件名；chmod a+w 文件名;chmod a-x 文件名 权限对文件 r(read)：可读取此文件的实际内容 w(write)：可以编辑、新增或者是修改该文件的内容（但不含删除该文件） x(execute)：该文件具有可以被系统执行的权限 权限对目录 r(read contents in directory)：表示具有读取目录结构清单的权限 w(modify contents of directory)：表示具有异动该目录结构清单的权限（创建，删除，更名，搬移文件/目录的位置） x(access directory)：代表使用者能否进入该目录成为工作目录，进入该目录的权限，（没有x不能进入该目录，即使有r/w） 文件拓展名 *.sh：脚本或批处理文件（script） Z，.tar，.tar.gz，.zip，*.tgz：经过打包后的压缩文件 .html，.php：网页相关文件 单一文件或目录的最大容许文件名为255Bytes（每个中文2Bytes） 绝对路径/相对路径 . ：代表当前的目录，也可以使用./来表示 .. ：代表上一层目录，也可以使用../来表示 cd：变换目录 pwd：显示当前的目录 mkdir：创建一个新的目录 [-m/-p]-m 设置文件的权限 -p递归创建所有目录 rmdir：删除一个空的目录 cp：复制文件 注意文件权限 mv：移动文件 rm：删除文件 文件内容查阅 cat：由第一行开始显示文件内容 tac：从最后一行开始显示 nl：显示的时候，顺道输出行号 more：一页一页的显示文件内容 less与more类似，它可以往前翻页 head：只看头几行 tail：只看尾几行 od：以二进制的方式读取文件内容 torch：修改文件时间或创建新文件 mtime：文件内容变更时更新这个时间（重要） ctime：文件的状态（权限与属性等）改变时更新这个时间 atime：文件内容被取用时更新这个时间 文件默认权限：umask（root：022；一般使用者：002） 三组数字代表从权限中拿掉哪种权限，创建文件则默认没有x，最大为666；创建目录最大为777。可以通过umask 002进行修改默认权限 chattr：设置文件隐藏属性 lsattr：显示文件隐藏属性 4–SUID、2–SGID、1–SBIT权限设置 file：文件的基本类型 which：寻找可执行文件 文件文件名的搜寻：先使用whereis或者时locate，找不到的话再使用find进行查找 updatedb：根据/etc/updatedb.conf的设置去搜寻系统硬盘内的文件名，并更新/var/lib/mlocate内的数据库文件 locate：依据/var/lib/mlocate内的数据库记载，找出使用者输入的关键字文件名 tar将多个文件打包成一个文件，但没有压缩功能，通过参数可以同时进行各种方式的压缩， gzip(*.gz)：在默认的状态下原本的文件会被压缩成为.gz的文件名，原始文件就不存在了 zcat读取压缩文件，egrep来在备份中的文本文件中查询数据 bzip2(*.bz2)压缩比比gzip高，bzcat/bzmore/bzless/bzgrep xz(*.xz)压缩比最高，xzcat/xzmore/xzless/xzgrep","categories":[],"tags":[{"name":"鸟叔的Linux私房菜","slug":"鸟叔的Linux私房菜","permalink":"http://yoursite.com/tags/鸟叔的Linux私房菜/"}]},{"title":"tomcat-浏览器同步","slug":"tomcat-浏览器同步","date":"2018-08-15T07:25:27.000Z","updated":"2018-08-15T07:47:48.000Z","comments":true,"path":"2018/08/15/tomcat-浏览器同步/","link":"","permalink":"http://yoursite.com/2018/08/15/tomcat-浏览器同步/","excerpt":"","text":"在项目中编辑了js脚本文件，但在浏览器中重新加载后发现所修改的js脚本并没有进行同步 首先，检查Tomcat配置 On ‘Update’ action : Update classes and resources On frame deactivation : Update classes and resources 上面这两个配置能在进行了代码的修改后直接通过页面右击重新加载来运行程序，不需要在IDEA中重新编译运行 然后在浏览器重新加载前进行浏览器缓存的清除","categories":[],"tags":[]},{"title":"PL/SQL","slug":"PL-SQL","date":"2018-08-14T06:39:24.000Z","updated":"2018-08-15T09:11:56.000Z","comments":true,"path":"2018/08/14/PL-SQL/","link":"","permalink":"http://yoursite.com/2018/08/14/PL-SQL/","excerpt":"PL/SQL简介PL/SQL是Oracle数据库对SQL语句的扩展，用来提高SQL的功能。在普通的SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言","text":"PL/SQL简介PL/SQL是Oracle数据库对SQL语句的扩展，用来提高SQL的功能。在普通的SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言 段 说明 声明 使用关键字declare，可选，限定在程序中使用的所有变量，游标，子程序和其他元素 可执行部分 封闭关键字begin和end，强制性的部分，它由程序的可执行文件的PL/SQL语句，应具有至少一个可执行的代码行，这可能仅仅是一个空命令，以指示什么都不执行 异常处理 使用关键字exception，可选，含有异常，在程序处理错误中 每一个PL/SQL语句都以分号结束，可嵌套在使用begin和end等PL/SQL块中 12345678//PL/SQL块的基本结构declare &lt;declarations section&gt;begin &lt;executable command(s)&gt;exception &lt;exception handling&gt;end; PL/SQL标识符是常量，变量，异常，过程，游标和保留字（不超过30个字符，默认不区分大小写） PL/SQL分隔符% 属性索引 ||连接运算符 **乘方运算符 :=赋值运算符 =&gt;操作关联符 PL/SQL注释– 单行注释 / …… /多行注释 PL/SQL条件控制语句IF-THEN语句 IF-THEN-ELSE语句 IF-THEN-ELSEIF-ELSE语句 CASE-WHEN语句 PL/SQL循环语句LOOP-END LOOP WHILE(condition) LOOP-END LOOP FOR value in initValue .. finalValue LOOP-END LOOP（计数器结果必须为数字，循环计数器增量必须为1） EXIT/EXXIT WHEN 退出循环 CONTINUE 退出本次循环 GOTO flag PL/SQL数组语法：create or replace type varray_name IS varray(n) of &lt;element_type&gt;（n是数组大小，element_type是数组元素的数据类型） 例：type grades IS varray(5) of INTEGER VARRAY的最大长度可以使用ALTER TYPE语句来改变 在Oracle环境中，可变数组的起始索引始终为1 数据库表的字段%type表明该数据和数据库表中的字段同类型 PL/SQL过程创建过程 123456789101112/* *procedure_name指定的程序的名称 *[or replace]选项允许修改现有的程序 *可选的参数列表中包含的名称，模式和类型的参数 *procedure_body包含可执行部分 *AS关键字来替代了IS关键字用于创建一个独立的程序 */create [or replace] procedure procedure_name [(parameter_name [in|out|in out] type [, ...])]&#123;IS|AS&#125;begin &lt;procedure_body&gt;end procedure_name; 例： 12345create or replace procedure greetingsASbegin dbms_output.put_line(\"Hello World!\");end; 执行独立程序 使用execute关键字execute greetings 从PL/SQL块调用过程的名称begin greetings end; 删除独立程序 drop procedure procedure_name 可以使用下面的语句删除greetings begin drop procedure greetings end; 参数 in参数传递一个值到子程序，是一个只读的参数，是参数传递的默认值，是通过引用传递 out参数返回一个值到调用程序，实际参数必须是变量，是按值传递 in out参数传递的初始值到一个子程序，并返回一个更新值给调用者，实际参数必须是一个变量，形参必须分配一个值，实际参数是按值传递 PL/SQL函数创建函数 123456789101112131415/* *function_name是指定的函数名称 *[or replace]选项允许修改现有的函数 *可选的参数列表中包含的名称，模式和参数的类型 *函数必须包含一个return语句 *return子句指定要在函数返回的数据类型 *function_body包含可执行部分 *AS关键字来代替了IS关键字用于创建一个独立的函数 */create [or replace] function function_name [(parameter_name [in|out|in out] type [, ...])]return return_datatype&#123;IS|AS&#125;begin &lt;function_body&gt;end [function_name]; 例： 1234567891011create or replace function totalUsersreturn numberIS total number(2) := 0;begin select count(*) into total from users; return total;end; 注：参数和过程一致","categories":[],"tags":[{"name":"Oracle存储过程笔记","slug":"Oracle存储过程笔记","permalink":"http://yoursite.com/tags/Oracle存储过程笔记/"}]},{"title":"java读写Excel","slug":"java读写Excel","date":"2018-08-10T02:48:22.000Z","updated":"2018-08-11T01:25:02.000Z","comments":true,"path":"2018/08/10/java读写Excel/","link":"","permalink":"http://yoursite.com/2018/08/10/java读写Excel/","excerpt":"Apache POI是用Java编写的免费开源的跨平台Java API，具有创建和维护各种Office OpenXML(OOXML)和OLE 2符合文档格式的功能，可对Word、Excel、PowerPoint进行读写操作。这里只粗略说明了一下对Excel文件的简单读写操作，更细节的操作请阅读官方文档。","text":"Apache POI是用Java编写的免费开源的跨平台Java API，具有创建和维护各种Office OpenXML(OOXML)和OLE 2符合文档格式的功能，可对Word、Excel、PowerPoint进行读写操作。这里只粗略说明了一下对Excel文件的简单读写操作，更细节的操作请阅读官方文档。 Maven依赖既支持XLS格式，又支持XLSX格式 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt; 使用首先建立与Excel表格对应的实体映射类Bean(attribute1,attribute2,…)读取Excel文档：XLSX的文档读取类为XSSFWorkBook，其实现了WorkBook接口，可通过File类进行构造，然后从Excel文档中根据所需行号等信息读取对应的行，最后根据列号定位到列表中的单元格读取其中各种类型的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//读取XLSX文档public List&lt;Bean&gt; readXLSX(File file) throws InvalidFormatException, IOException&#123; Workbook workbook = new XSSFWorkbook(file); Sheet sheet = new XSSFWorkbook(file).getSheetAt(0);//也可以通过Sheet名获取Sheet对象，getSheet(\"name\") List&lt;Bean&gt; result = new ArrayList&lt;Bean&gt;(); int rowStart = sheet.getFirstRowNum() + 1;//如果列表上有列表描述则+1，没有则不需要 int rowEnd = sheet.getLastRowNum(); for(int i = rowStart; i &lt; rowEnd + 1; i++)&#123; Row row = sheet.getRow(i);//获取sheet的行对象 Bean bean = this.getBeanFromRow(row); if(bean != null) result.add(bean); &#125; return result;&#125;//读取XLS文档public List&lt;Bean&gt; readXLS(File file) throws InvalidFormatException, IOException&#123; POIFSFileSystem poifsFileSystem = new POIFSFileSystem(new FileInputStream(file)); Sheet sheet = new HSSFWorkbook(poifsFileSystem).getSheetAt(0); int rowStart = sheet.getFirstRowNum() + 1; int rowEnd = sheet.getLastRowNum(); for(int i = rowStart; i &lt; rowEnd + 1; i++)&#123; Row row = sheet.getRow(i); Bean bean = this.getBeanFromRow(row); if(bean != null) result.add(bean); &#125; return result;&#125;//遍历每一行获取具体单元格中的数据并写入Bean对象中返回protected Bean getBeanFromRow(Row row)&#123; if(row == null) return null; int index = row.getFirstCellNum();//获取第一个单元格的列数 Cell cell = row.getCell(index); if(cell != null)&#123; Bean bean = new Bean(); bean.setAttribute1(cell.getStringCellValue()); index++; cell = row.getCell(index); bean.setAttribute2(cell.getStringCellValue()); return bean; &#125; return null;&#125; 写入Excel文档：可以通过文件进行构造，然后创建工作表，然后通过行和列定位到具体的单元格中进行写入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//针对XLSXFile file;OutputStream os;Workbook workbook = null;//构造函数public Construct(File file) throws InvalidFormatException,IOException,ClassNotFoundException&#123; this.file = file; if(!file.exists()) file.createNewFile(); os = new FileOutputStream(file); workbook = new XSSFWorkbook();//如果是XLS格式则改成HSSFWorkbook Sheet sheet = workbook.createSheet(\"Bean\"); Field[] fields = Class.forName(\"Bean类名\").getDeclaredFields(); Row titleRow = sheet.createRow(0); for(int i = 0; i&lt;fields.length; i++)&#123; Cell cell = titleRow.createCell(i); cell.setCellValue(field[i].getName()); &#125;&#125;//将单个Bean对象写入Excelpublic void write(Bean bean) throws IOException,ClassNotFoundException&#123; Sheet sheet = workbook.getSheet(\"Bean\"); int lastRowNum = sheet.getLastRowNum(); Row index = sheet.createRow(lastRowNum + 1); //通过反射机制获取类的属性以及get方法（通用）读取文件的时候也可以改为这种方式 Class clazz = bean.getClass();//Class.forName(\"Bean类名\");//Bean.class Field[] fields = clazz.getDeclaredFields(); //index.createCell(0).setCellFormula(\"row-1\"); for(int i = 0; i&lt;fields.length; i++)&#123; //通过反射来执行Bean的get方法 index.createCell(i).setCellValue( （String)clazz.getMethod(\"get\"+toUpperFirstWord( fields[i].getName()),null).invoke(bean,null)); &#125;&#125;//将多个Bean对象写入Excelpublic void write(Collection&lt;Bean&gt; beans) throws IOException&#123; for(Bean bean : beans)&#123; this.write(bean); &#125;&#125;// 创建文件输出流，准备输出电子表格：这个方法发在调用前面的方法之后必须执行，否则你在sheet上做的任何操作都不会有效public void execute() throws IOException&#123; workbook.write(os); workbook.close();&#125;//将字符串的首字母大写private String toUpperFirstWord(String str)&#123; if(str != null &amp;&amp; str != \"\")&#123; str = str.substring(0,1).toUpperCase()+str.substring(1); &#125; return str;&#125; 测试小Demo请移步GitHub：https://github.com/ZivvCai/ExcelDemo","categories":[],"tags":[{"name":"使用Apache POI读写Excel文档","slug":"使用Apache-POI读写Excel文档","permalink":"http://yoursite.com/tags/使用Apache-POI读写Excel文档/"}]},{"title":"快捷键冲突","slug":"快捷键冲突","date":"2018-08-07T03:00:05.000Z","updated":"2018-08-07T03:06:22.000Z","comments":true,"path":"2018/08/07/快捷键冲突/","link":"","permalink":"http://yoursite.com/2018/08/07/快捷键冲突/","excerpt":"在使用IDEA的过程中，win10默认输入法下，如果把输入法切换成中文，不能使用Ctrl+Shift+F进行全文查找，输入法也会变成繁体","text":"在使用IDEA的过程中，win10默认输入法下，如果把输入法切换成中文，不能使用Ctrl+Shift+F进行全文查找，输入法也会变成繁体 原因：输入法的快捷键和IDEA中的快捷键冲突 解决办法： 1、自己注意在IDEA编辑状态下的输入法格式； 2、安装另外的输入法（建议使用系统自带的英语(美式)键盘）","categories":[],"tags":[{"name":"IDEA快捷键操作","slug":"IDEA快捷键操作","permalink":"http://yoursite.com/tags/IDEA快捷键操作/"}]},{"title":"velocity","slug":"velocity","date":"2018-07-30T01:42:51.000Z","updated":"2018-07-30T03:00:14.000Z","comments":true,"path":"2018/07/30/velocity/","link":"","permalink":"http://yoursite.com/2018/07/30/velocity/","excerpt":"Velocity是一个基于java的模板引擎（template engine），它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。","text":"Velocity是一个基于java的模板引擎（template engine），它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。 基本语法 “#”用来标识Velocity的脚本语句，包括”#set“，”#if“，”#else“，”#end“，”#foreach“，”#include“等 ”$“用来标识一个对象（或理解为变量） ”{}“用来明确标识Velocity变量 ”!“用来强制把不存在的变量显示为空白：如当页面中包含$msg，如果$msg有值，将显示msg的值；如果不存在值，将显示”$msg“字符。”!“可以把不存在的变量或变量值为null的对象显示为空白。 基本的模板脚本语句 $!obj 直接返回对象结果 #if($!obj) #else #end 判断语句 #foreach($info in $list)$info.someList #end 循环读取集合list中的对象，并作相应的处理 #macro(macroName) #end 脚本函数（宏）调用，不推荐在界面模板中大量使用，函数（宏）定义，一般放在最前面 包含文件#include(“模板文件名”)或#parse(“模板文件名”) 主要用于处理具有相同内容的页面，比如每个网站的顶部和尾部内容。parse和include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示 关于#set的使用， Velocity脚本语法摘要 声明：#set($var=XXX) var可以是以下内容：Variable reference，String literal ，Property reference，Method reference，Number literal #set($i=1)，ArrayList #set($arr=[“yt1”,”t2”])，算术运算符 注释：单行## XXX，多行 # XXX # 变量Variables：以”$”开头，第一个字符必须为字母 Properties：$user.name hashtable user中的name值，类似 user.get(“name”) Methods：object user.getName() = $user.getName() Formal Reference Notation：用{}把变量名跟字符串分开 双引号与引号：#set($var=”hello”) test”$var” 返回testhello；test’$var’ 返回test’$var’ 可以通过设置stringliterals.interpolate=false改变默认处理方式 条件语句#if($foo)#end：当$foo非空或为true是执行 逻辑运算符：== &amp;&amp; || ! 循环语句#foreach($var in $arrays) #end：集合包括以下三种：Vector，HashTable，Array velocityCount变量在配置文件中定义（velocityCount是循环的索引值）：directive.foreach.counter.name = velocityCount directive.foreach.counter.initial.value = 1 包含文件：#include(“文件名+后缀”) Parse导入脚本：#parse(“me.vm”) #stop停止执行并返回 定义宏Velocimacros，相当于函数，支持包含功能：定义：#macro(d) \\\\\\&lt;\\td&gt;\\&lt;\\tr&gt; #end 调用：#d() 带参数的宏：#macro(tablerows $color $somelist) #foreach($something in $somelist) \\\\$something\\&lt;\\td&gt;\\&lt;\\tr&gt; #end #end Range Operator：#foreach($foo in [1..5])","categories":[],"tags":[{"name":"velocity语法笔记","slug":"velocity语法笔记","permalink":"http://yoursite.com/tags/velocity语法笔记/"}]},{"title":"svn学习笔记","slug":"svn学习笔记","date":"2018-07-26T02:27:03.000Z","updated":"2018-07-30T09:06:02.000Z","comments":true,"path":"2018/07/26/svn学习笔记/","link":"","permalink":"http://yoursite.com/2018/07/26/svn学习笔记/","excerpt":"SVN简介Subversion(SVN)是一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库中。","text":"SVN简介Subversion(SVN)是一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库中。 repository：源代码库 Checkout：提取/检出 Commit：提交 Update：更新 SVN生命周期创建版本库：版本库相当于一个集中的空间，使用Create来创建一个新的版本库 检出：Checkout操作是用来从版本库中创建一个工作副本 更新：Update操作是用来更新版本库的，将工作副本与版本库进行同步，由于版本库是整个团队共用的，当其他人提交了他们的改动之后，你的工作副本就会过期，需进行更新同步才能将改动提交 执行变更：在副本中的各种操作，都只是被添加进待变更列表中 复查变化：Status操作用来查看待变更列表，但并不提供变动的详细信息，可以用diff操作来查看变动的详细信息 修复错误：Revert操作重置对工作副本的修改，既可以重置一个或多个文件/目录，也可以重置整个工作副本 解决冲突：Merge操作会自动处理可以安全合并的东西，Resolve操作用来找出冲突并告诉版本库如何处理这些冲突 提交更改：Commit操作是用来将更改从工作副本到版本库，Commit是一个原子操作，要么完全提交成功，要么失败回滚 SVN操作创建版本库： 手动新建版本库目录：mkdir /opt/svn 利用SVN命令创建版本库：svnadmin create /opt/svn/repository 使用命令svnserver启动服务：svnserver -d -r 目录 –listen-port 端口号（-r：配置方式决定了版本库访问方式；–listen-port：指定SVN监听端口，不加此参数，SVN默认监听3690端口） /conf目录下修改默认配置文件配置相关用户和权限 SVN服务配置文件svnserver.conf：(write–可读可写,read–只读,none–无访问权限) anon-access：控制非鉴权用户访问版本库的权限，缺省：read auth-access：控制鉴权用户访问版本库的权限，缺省：write authz-db：指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制，缺省：authz realm：指定版本库的认证域，即在登录时提示的认证域名称，缺省：一个UUID(全局唯一标示) 用户名口令文件password：由svnserver.conf的配置项password-db指定，缺省为conf目录中的password，该文件仅由一个[users]配置段组成，格式\\&lt;用户名&gt; = \\&lt;口令&gt; 权限配置文件：由svnserver.conf的配置项authz-db指定，缺省为conf目录中的authz，该文件由一个[groups]配置段和若干个版本库路径权限段组成，格式\\&lt;用户组&gt; = \\&lt;用户列表&gt;，版本库路径权限段名格式[\\&lt;版本库名&gt;:\\&lt;路径&gt;] [groups]g_admin = admin,thinker [admintools:/] @g_admin = rw * = 检出操作： svn checkout http://svn.svnserver.com/svn/project_repo –username=user 例：svn checkout svn://192.168.0.1/repository –username=user01 在当前目录下生成repository副本，查看检出内容：ll reposiroty/ info命令查看版本库信息 解决冲突： 在提交更改之前必须先更新工作副本：svn update 默认是更新到最新的版本，也可以指定更新到哪个版本：svn update -r6 提交操作： svn add file：将文件添加到版本控制，等待提交到版本库 查看副本中的状态：svn status（?未添加到版本控制中，A表示添加到了版本控制中） svn commit -m “添加注释信息”：添加版本控制到版本库，修改版本号自动加1，忽略-m选项，SVN会打开一个可以输入多行的文本编辑器来让你输入提交信息 SVN版本回退： svn revert操作将撤销任何文件或目录里的局部更改 svn revert file/svn revert -R 目录 svn merge -r 22:21 readme 回退版本，从22回退到21 查看历史信息： svn log：用来展示svn的版本、日期、路径等，svn log -r 版本号：版本号 比较两个版本之间的信息，svn log 文件路径 查看具体文件的版本修改信息 svn diff：用来显示特定修改的行级详细信息，svn diff比较工作文件与缓存在.svn的“原始”拷贝；svn diff -r 版本号 文件名 比较工作拷贝和版本库；svn diff -r 版本号:版本号 文件名 比较版本库与版本库 svn cat：取得在特定版本的某文件显示在当前屏幕，svn cat -r 版本号 文件 svn list：显示一个目录或某一版本存在的文件，不用下载文件到本地，svn list URL SVN分支： svn copy trunk/ branches/my_branch 创建分支就是重新创建一个目录 SVN标签： 标签代表一个可以固定的完整的版本，svn copy 目录trunk/ 目录tags/v1.0，提交tag内容 使用TortoiseSVN，然后基本就是可视化界面，右键即可有快速入口，操作简单。。","categories":[],"tags":[{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"}]},{"title":"金融基础知识汇总","slug":"金融基础知识汇总","date":"2018-07-11T12:11:45.000Z","updated":"2018-07-30T06:36:20.000Z","comments":true,"path":"2018/07/11/金融基础知识汇总/","link":"","permalink":"http://yoursite.com/2018/07/11/金融基础知识汇总/","excerpt":"","text":"主要就是银行、期货、基金、信托、证券相关实务知识。。。","categories":[],"tags":[{"name":"基础金融知识","slug":"基础金融知识","permalink":"http://yoursite.com/tags/基础金融知识/"}]},{"title":"redis","slug":"redis","date":"2018-07-03T12:19:38.000Z","updated":"2018-07-03T12:19:40.000Z","comments":true,"path":"2018/07/03/redis/","link":"","permalink":"http://yoursite.com/2018/07/03/redis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"windows DOS窗口MySQL操作命令","slug":"windows-DOS窗口MySQL操作命令","date":"2018-03-01T08:49:30.000Z","updated":"2018-07-11T14:48:32.000Z","comments":true,"path":"2018/03/01/windows-DOS窗口MySQL操作命令/","link":"","permalink":"http://yoursite.com/2018/03/01/windows-DOS窗口MySQL操作命令/","excerpt":"安装并配置好MySQL之后可以使用windows下的DOS窗口进行数据库的操作。 net start mysql 启动mysql数据库 net stop mysql 关闭mysql数据库","text":"安装并配置好MySQL之后可以使用windows下的DOS窗口进行数据库的操作。 net start mysql 启动mysql数据库 net stop mysql 关闭mysql数据库 mysql -u root -p 然后输入密码后进入mysql操作 show databases; 显示你有的数据库(记得加”;”再回车) exit; 退出mysql数据库 use database 使用某个数据库 show tables 显示当前使用数据库中的表 之后便可以使用相应的SQL语句进行数据库的增删改查","categories":[],"tags":[{"name":"指令备忘","slug":"指令备忘","permalink":"http://yoursite.com/tags/指令备忘/"}]},{"title":"TestNG","slug":"TestNG","date":"2018-02-11T12:59:24.000Z","updated":"2018-07-12T12:21:56.000Z","comments":true,"path":"2018/02/11/TestNG/","link":"","permalink":"http://yoursite.com/2018/02/11/TestNG/","excerpt":"##关于TestNG TestNG是一个开源自动化测试框架，它消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。因为它在很大程度上借鉴了Java注解来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。","text":"##关于TestNG TestNG是一个开源自动化测试框架，它消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。因为它在很大程度上借鉴了Java注解来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。 特点 注解 TestNG使用Java和面向对象的功能 支持综合类测试（例如，默认情况下，不用创建一个新的测试每个测试方法的类的实例） 独立的编译时测试代码和运行时配置/数据信息 灵活的运行时配置 主要介绍“测试组” 支持依赖测试方法，并行测试，负载测试，局部故障 灵活的插件API 支持多线程测试 TestNG注解列表 注解 描述 @BeforeSuite 在该套件的所有测试都运行在注释的方法之前，仅运行一次 @AfterSuite 在该套件的所有测试都运行在注释方法之后，仅运行一次 @BeforeClass 在调用当前类的第一个测试方法之前运行，注释方法仅运行一次 @AfterClass 在调用当前类的第一个测试方法之后运行，注释方法仅运行一次 @BeforeTest 注释的方法将在属于\\标签内的类的所有测试方法运行之前运行 @AfterTest 注释的方法将在属于\\标签内的类的所有测试方法运行之后运行 @BeforeGroups 配置方法将在之前运行组列表。此方法保证在调用属于这些组中的任何一个的第一个测试方法之前不久运行 @AfterGroups 配置方法将在之后运行组列表。该方法保证在调用属于任何这些组的最后一个测试方法之后不久运行 @BeforeMethod 注释方法将在每个测试方法之前运行 @AfterMethod 注释方法将在每个测试方法之后运行 @DataProvider 标记一种方法来提供测试方法的数据。注释方法必须返回一个Object[][]，其中每个Object[]可以被分配给测试方法的参数列表。要从该DataProvider接收数据的@Test方法需要使用与此注释名称相等的dataProvider名称 @Factory 将一个方法标记为工厂，返回TestNG被用作测试类的对象。该方法必须返回Object[] @Listeners 定义测试类上的侦听器 @Parameters 描述如何将参数传递给@Test方法 @Test 将类或方法标记为测试的一部分 使用注解的好处： TestNG可以通过查找注解来识别它感兴趣的方法 可以将其他参数传递给注释 注释是强类型的，所以编译器会马上标记任何错误 测试类不再需要扩展任何东西 具体用法参见：https://www.yibai.com/testng","categories":[],"tags":[{"name":"TestNG笔记","slug":"TestNG笔记","permalink":"http://yoursite.com/tags/TestNG笔记/"}]},{"title":"JUnit","slug":"JUnit","date":"2018-02-09T12:59:13.000Z","updated":"2018-07-12T12:22:48.000Z","comments":true,"path":"2018/02/09/JUnit/","link":"","permalink":"http://yoursite.com/2018/02/09/JUnit/","excerpt":"关于JUnitJUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。JUnit促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 所谓单元测试是测试应用程序的功能是否能够按需要正常运行，并且确保是在开发人员的水平上，单元测试生成图片。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。","text":"关于JUnitJUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。JUnit促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 所谓单元测试是测试应用程序的功能是否能够按需要正常运行，并且确保是在开发人员的水平上，单元测试生成图片。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。 特点 JUnit是一个开放的资源框架，用于编写和运行测试。 提供注释来识别测试方法。 提供断言来测试预期结果。 提供测试运行来运行测试。 JUnit测试允许你编写代码更快，并能够提高质量。 JUnit测试可以自动运行并且检查自身结果并提供即时反馈。 JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。 JUnit测试框架 JUnit是一个回归测试框架，被开发者用于实施对应用程序的单元测试，加快程序编制速度，同时提高编码的质量。JUnit测试框架具有以下重要特性： 测试工具：是一整套固定的工具由于基线测试。测试工具的目的是为了确保测试能够在共享且固定的环境中运行，因此保证测试结果的可重复性。包括：在所有测试调用指令发起前的setUp()方法；在测试方法运行后的tearDown()方法。 测试套件：意味捆绑几个测试案例并且同时运行。在JUnit中，@RunWith和@Suite都被用作运行测试套件。 测试运行器：用于执行测试案例。 JUnit测试分类 包含一套断言方法的测试断言 包含规定运行多重测试工具的测试用例 包含收集测试用例结果的方法的测试结果 JUnit APIJUnit中的最重要的程序包是junit.framework。 类名 类的功能 Assert assert方法的集合 TestCase 一个定义了运行多重测试的固定装置 TestResult TestResult集合了执行测试样例的所有结果 TestSuite TestSuite是测试的集合 Assert类 方法 描述 void assertEquals(boolean expected,boolean actual) 检查两个变量或等式是否平衡 void assertFalse(boolean condition) 检查条件是假的 void assertNotNull(Object object) 检查对象不是空的 void assertNull(Object object) 检查对象是空的 void assertTrue(boolean condition) 检查条件为真 void fail() 在没有报告的情况下使测试不通过 void assertSame(boolean condition) 检查两个相关对象是否指向同一个对象 void assertNotSame(boolean condition) 检查两个相关对象是否不指向同一个对象 void assertArrayEquals(expectedArray,resultArray) 检查两个数组是否相等 TestCase 方法 描述 int countTestCases() 为被run(TestResult result)执行的测试案例计数 TestResult createResult() 创建一个默认的TestResult对象 String getName() 获取TestCase的名称 TestResult run() 一个运行这个测试的方便的方法，收集由TestResult对象产生的结果 void run(TestResult result) 在TestResult中运行测试案例并收集结果 void setName(String name) 设置TestCase的名称 void setUp() 创建固定装置，例如：打开一个网络连接 void tearDown() 拆除固定装置，例如：关闭一个网络连接 String toString() 返回测试案例的一个字符串表示 TestResult类 注释 注释 描述 @Test 这个注释说明依附在JUnit的public void方法可以作为一个测试案例 @Before 有些测试在运行前需要创造几个相似的对象。在public void方法加该注释是因为该方法需要在test方法前运行 @After 如果你将外部资源在Before方法中分配，那么你需要在测试运行后释放他们。在public void方法加该注释是因为该方法需要在test方法后运行 @BeforeClass 在public void方法加该注释是因为该方法需要在类中所有方法前运行 @AfterClass 它将会使方法在所有测试结束后执行。这个可以用来清理活动 @Ignore 这个注释是用来忽略有关不需要执行的测试的 具体用法参见：https://www.w3cschool.cn/junit","categories":[],"tags":[{"name":"JUnit笔记","slug":"JUnit笔记","permalink":"http://yoursite.com/tags/JUnit笔记/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2018-01-31T08:50:50.000Z","updated":"2018-07-12T12:22:26.000Z","comments":true,"path":"2018/01/31/Linux基础/","link":"","permalink":"http://yoursite.com/2018/01/31/Linux基础/","excerpt":"Linux文件系统概述文件系统具有以下特点： 文件系统是由文件及目录组成 每个目录或者文件在磁盘上都对应了一定的存储空间 每个目录或者文件都可以被复制或者删除，除了一些只读的文件系统外 如果有多个存储实体，比如磁盘、U盘，那么，它们将对应多个并列的、不同的文件系统 文件系统有不同的类型","text":"Linux文件系统概述文件系统具有以下特点： 文件系统是由文件及目录组成 每个目录或者文件在磁盘上都对应了一定的存储空间 每个目录或者文件都可以被复制或者删除，除了一些只读的文件系统外 如果有多个存储实体，比如磁盘、U盘，那么，它们将对应多个并列的、不同的文件系统 文件系统有不同的类型 目录名 描述 bin 用户级二进制工具 boot Linux内核镜像文件，由bootloader程序读取并装载 dev 各种系统硬件设备 etc 系统配置文件及其他配置文件 home 用户工作目录 lib 系统运行时所需的各种库文件 opt 操作系统附带的一些应用程序 proc 内核及进程所虚拟的系统文件 root 管理员工作目录 sbin 与bin的区别在于，该目录下的二进制工具程序仅用于管理员 sys 一般是驱动程序对应的虚拟文件系统 usr 管理安装的、所有用户都可以访问的应用程序 var 系统运行时所产生的一些调试信息文件或者相关统计文件 注：Linux系统根目录结构 Linux启动过程通用系统的启动过程：开机并执行bootloader程序—&gt;操作系统内核初始化—&gt;执行第一个应用程序 第一步是开机，开机是给系统供电，此时硬件电路会产生一个确定的复位时序，保证CPU是最后一个被复位的器件。当正确完成复位后，CPU开始执行第一条指令，该指令所在的内存地址是固定的，这由CPU的制造者指定，这个固定地址所保存的程序往往被称为“引导程序”（Bootloader），因为其作用是装载真正的用户程序。不同的CPU会提供不同的装载方式，有的是通过普通的并口存储器，有的则是通过SD卡、RS232接口等。装载过程必须提供以下信息： 从哪里读取用户程序？ 用户程序的长度是多少？ 装载完用户程序后，应该跳转到哪里，即用户程序的执行入口在哪里？ 第二步是执行内核程序，这里的内核程序是指上一步中的用户程序。内核程序初始化时执行的操作包括，初始化各种硬件，包括内存、网络接口、显示器、输入设备，然后建立各种内部数据结构，这些数据结构将用于多线程调度及内存的管理等 第三步是运行Home程序，Home程序是指通过改程序可以很方便地启动其他应用程序，传统的Linux系统启动后，第一个运行程序一般是一个Terminal，尽管它表面上就像一个Dos界面，但它也可以被称为Home程序，因为Home程序设计的目的就是提供一个入口，用户可以通过该入口启动其他应用程序 ##常用Linux命令 man：当我们不清楚某个Linux命令的作用和用法时，可以使用man command进行查询，command为具体的命令名称 find：find命令用于查找某个文件或文件夹，比如find . -name &quot;*.java&quot;该命令用于查找当前目录下扩展名为Java的所有文件find后面的”点“代表当前目录，*为通配符，代表任何名称 grep：为正则表达式匹配命令，该命令用于字符串匹配。例：grep &quot;Activity&quot; hello.java。grep和find的区别在于：find用于查找目录或文件，而grep用于查找指定的字符串，并且字符串可以由正则表达式描述 xargs：xargs并不是一个命令，而是一个标识，代表了上一个命令的执行结果，并作为下一个命令的参数。Linux命令可以流水线执行，也称”多管道“执行，即两个命令用”|“分隔符隔开。比如，想查找当前目录下文件名中包含”oa“的所有文件，可以使用如下命令：ls | xargs grep &quot;oa&quot; cat：cat命令用于连接文件内容并在Terminal中输出文件内容，该命令后面如果只有一个文件名称，则仅输出该文件内容 sudo：用在命令前，含义是使用管理员权限执行后续的命令，因为有些命令要求有管理员权限 chmod：在Linux系统中，文件的访问者被划分为三类，并针对这三类用户指定不同的访问权限。这三类访问者是：user(u)，用户自身，即创建该文件的用户；group(g)，用户所在组，即与创建在一个组里面的用户；other(o)，其他用户。chmod命令就是用于设置这三类访问者对某文件的访问权限。访问权限分为读(r)权限、写(w)权限、执行(x)权限，文件类型不同，”执行“的含义不同。可以通过ls -l命令查看文件的访问权限，Linux系统使用10位(bit)数据表示访问的权限。bit 0：使用-或者d表示，前者表示这是一个文件，后者表示这是一个目录；bit 1~bit 3：用户自身(user)对该文件的访问权限；bit 4~bit 6：用户组(group)对该文件的访问权限；bit 7~bit 9：其他用户(other)对该文件的访问权限。例：某个文件的属性为-rwxrwx---，这表示它是个文件，用户对文件拥有读取、写入、执行权限，用户组对该文件也拥有读取、写入、执行权限，而其他用户则不能读取、不能写入、不能执行。修改文件权限chmod u+x copy.sh命令中u+x的含义是给user添加执行(x)的权限，类似的也可以是o+x、o+rw、g+rwx等，可以用a代表所有用户。对于某些Linux系统，chmod不识别r、w、x这样的参数，而只能使用8进制数字值来表示，chmod 777 copy.sh其中777为8进制的数，对应二进制数据为111 111 111，这就分别代表了u、g、o三类用户的访问权限 ps，kill：ps用于列出当前运行的所有进程，kill用于杀死某个进程。这两个命令多用于系统调试，比如，可以先用ps列出所有进程，从输出信息中得到每个进程的id值，即pid，然后调用kill -9 pid就可以杀死指定pid对应的进程。-9是一个参数，具体可用man kill查看 export：该命令用于将某个变量值的作用域设为全局范围 cd 、ls、cd .. Shell脚本备忘凡是需要按一定的次序执行多个Linux命令的场合都可以使用脚本来完成 1、获取输入 输入包含三种：第一种是执行脚本时用户的输入；第二种是将前一个脚本的输出作为该脚本的输入；第三种是脚本函数的参数。用户的输入可以用$n表示，n为1~9自然数，分别代表输入中的第n个参数 123456789#!/bin/bashecho $1echo $2echo $3执行该脚本，输出为：$./me i love youiloveyou 2、变量定义 在Bash脚本中的变量没有类型，所有的变量都是字符串。变量不要单独定义，可直接赋值，赋值语句中不能有空格。引用变量时只需在变量前加一个$符号即可。为了避免混淆，常常使用双引号包含要引用的变量 12345678#!/bin/bashA=bAll=allecho &quot;$A&quot;llecho $All执行后输出为：bllall 3、条件判断 条件判断主要是判断两个字符串 是否相等、两个数字是否相等。其语法格式如下： 12345678#!/bin/bashif [ &quot;$1&quot; = &quot;normal&quot; ]then echo &quot;this is normal case&quot;elif [ -z &quot;$1&quot; ]then echo &quot;no input,ignal...&quot;fi 该段代码判断用户输入的第一个参数，如果其值等于”normal“字符串，则显示”this is normal case“，如果第一个参数为空，则显示”no input，ignal…“ 条件判断语法中要注意： 每个if语句后面的执行部分必须跟在then后面 多个判断分支可以使用elif语句 条件语句必须使用fi结束 条件语句中”[”符号后面必须要有一个空格 Bash脚本的比较运算符 操作符 返回true的条件 操作数的个数 -n 操作数的长度不为零 1 -z 操作数的长度为零 1 -d 操作数对应一个目录 1 -f 操作数对应一个文件 1 -eq 操作数为整数，并且相等 2 -neq 操作数为整数，但不相等，与-eq相反 2 = 操作数为字符串，并且相等 2 != 操作数为字符串，但不相等，与=相反 2 -lt 小于（less than），操作数为整数 2 -gt 大于（great than），操作数为整数 2 -ge 大于等于（great equal），操作数为整数 2 -le 小于等于（less equal），操作数为整数 2 4、while []…do…done语句 该语句类似于C语言中的do…while语句，举例如下： 12345678910111213141516171819202122#!/bin/bashecho &quot;please use add or delete or exit&quot;ACTION=&quot;default&quot;while [ -n $ACTION ]do read ACTION case $ACTION in add) echo &quot;add somebody&quot; ;; delete) echo &quot;delete somebody&quot; ;; exit) echo &quot;complete&quot; break ;; *) echo &quot;invalide action,please re-enter&quot; ;; esacdone 以上脚本的作用是根据用户输入的参数，执行不同的内容。read是一个Linux命令，用于提示用户输入并以按回车键（LF）结束输入。输入的内容保存到变量ACTION中，接下来的case语句根据ACTION的值，执行不同的动作，esac也是一个Linux命令，这里可以理解为case语句的结束标识。要退出整个while循环，可以使用break语句，done语句是整个while语句的结束标识 5、for循环 Bash中的for循环类似于Java中的foreach语句，for一般与in联合使用，用于从某个集合中逐个取出元素并对其进行操作 1234567#!/bin/bashfor X in `ls`do echo `basename $X` echo `dirname $X`doneuname 在这段代码中，in集合的来源是Linux ls命令，即当前目录下的所有文件。需要注意的是如果要把Linux的某个命令的输出作为集合，或者作为其他命令的输入，需要把该命令包含在“`”符号之中，该符号是键盘上！符号左边的那个按键；如果仅仅是执行某个Linux命令则不需要上述符号。代码中basename和dirname命令用于显示一个字符串中的路径和文件名称，例如/user/local/lib/lib.so对应的dirname是/user/local/lib，对应的basename是lib.so。其本身并不去检测该文件是否真正存在于磁盘上，而仅仅是针对字符串的操作 6、函数 1234567891011121314151617181920212223242526#!/bin/bashstrcat()&#123; OUT=&quot;$1&quot;&quot; &quot;&quot;$2&quot; return 0&#125;strcat2()&#123; echo &quot;$1&quot;&quot; &quot;&quot;$2&quot; return 3&#125;A=&quot;bird&quot;B=&quot;mouse&quot;OUT=&quot;&quot;strcat $A $Becho $OUTOUT2=`strcat2 $A $B`echo $?echo $OUT2运行该脚本的输出为：bird mouse3bird mouse 脚本中的函数具有以下特点： 定义函数时，不需要定义参数，在函数实体中可以直接使用$1代表输入的第n个参数 函数可以使用return关键字返回整数数值，但return返回数值并不能通过等号赋值给函数的调用者，函数必须使用echo命令返回内容给调用者 调用函数时，如果要获得函数的输出，并且赋值给某个变量，则函数的执行必须包含在“`”符号之间 如果要获得函数的返回值而不是输出，即函数中return关键字后面的数值则可以使用$?符号。该符号代表了上一个命令的返回值，所谓的上一个命令可以是一个函数，也可以是一个Linux命令，在一般情况下，return关键字返回的数值应该用于表明脚本的执行状态结果 7、常用内置符号常量 内置符号常量 符号值 意义 $@ 代表全部参数，比如test a b c，此处为“a“ ”b“ ”c”，展开后为三个字符串 $* 全部参数，比如test a b c，此处为“a b c”，展开后为一个字符串 $# 参数的个数，比如test a b c，此处是3 \\$? 上一个命令的返回结果，如果上一个命令是脚本函数，则对应函数中return的数值，比如ls\\ echo”$?”，结果为0 $$ 当前命令所在的进程号（PID） ##Make脚本备忘 Linux系统中包含一个Make脚本的解释器，它可以读取Make脚本的内容，并执行之，Make脚本多用于自动编译过程。Make脚本的基本语法如下： 12目标(target):条件(prerequest)(Tab键)命令 在该语法中，目标可以是任意一个字符串名称，也可以是具体文件的名称，条件可以是其他目标的名称，也可以是具体文件的名称。执行Make脚本时，Make解释器会检查目标和条件中包含的文件时间戳是否相同，如果不同，解释器就会执行Tab键后面的命令，命令可以使任何可执行程序。 自动编译的基本原理是将目标文件作为“目标”，将源文件作为“条件”，因此，当源文件被修改过后，目标文件的时间戳就会早于源文件，于是Make解释器便会自动执行指定的“命令”。此时可以将执行编译的命令作为这里的“命令”，从而达到自动编译的目的。 1234567891011121314#Filename Makefile#this file is used for show how to use makefile$(info start working)hello:hello.c echo &quot;nothing&quot;hello.bin:hello.c @echo &quot;now make hello.bin&quot; gcc hello.c -o hello.bin.PHONY:hehe:hello.c @echo &quot;now make he&quot; gcc hello.c -o hello.bin 该段代码有以下特点： #是注释符，可以用在代码中任何地方 第三行中$是函数调用符号，info是一个函数名称，作用是输出一段信息。类似的信息输出函数还包括warning、error两个函数，不过error函数执行后会终止执行并退出 目标定义前不能加任何空格，而命令行前必须以Tab键开始 .PHONY关键字用于声明一个目标，被.PHONY声明的目标将总是执行其指定的命令，而如果不声明的话，则仅当目标后面的条件变动后才执行 命令前面的@符号的作用是，不显示被执行的命令。因为在默认情况下，Make解释器在执行命令时会打印出执行的命令 对于hello.bin目标，该目标本身是一个文件，其依赖的文件是hello.c文件。因此当hello.c文件被修改后，将会执行gcc命令重新对该c文件编译，并输出hello.bin文件 要执行以上脚本，可运行make -f Makefile hello，在该命令中，-f参数用于指定要执行的脚本文件名称。如果不指定文件名称，则解释器会自动从当前目录下寻找名称为Makefile的脚本文件，如果找不到，则执行失败。hello代表要执行的具体目标，因为一个脚本文件中可能包含多个目标的定义。如果不指定目标，则解释器默认执行脚本中定义的第一个目标。指定的目标不同，执行的命令也将不同 对于hello和he目标，因为它们不是文件名称，所以每次Make该目标时，都会执行指定的命令；而对于hello.bin，由于它是一个文件，因此，只有当hello.c被修改后才会执行编译命令 对于hello和he目标，由于这两个目标不是文件，所以其条件中所指定的hello.c文件其实没有什么意义，其对应的命令总是会被执行 1、变量的定义与赋值 Makefile中的变量不需要单独定义，可直接赋值 Make脚本中的变量赋值符号 赋值符号 意义 := 简单展开型，它在该Makefile被解析时就立即展开并赋值 = 递归展开型，该赋值方式只有当所定义的变量在使用的时候才展开 ?= 条件赋值，只有当该变量还没有值时才赋值 += 附加赋值 2、条件控制语句 Make脚本的条件控制可分为两类：一类是在解释器解析脚本文件时处理，另一类是在执行脚本时处理 第一类条件控制语句的语法模型 123456789if-condition text if the condition is trueendif或者if-condition text if the condition is trueelse text if the condition id falseendif 其中condition只能进行两种判断，一种是判断表达式是否相等，另一种是判断表达式是否被定义，如下： ifdef var，判断变量var是否被定义过。如前所述，脚本并不需要单独定义，只要给该变量赋值过，那么它就被定义了 ifndef var，与ifdef相反，判断变量var是否还没有被定义 ifeq test，判断表达式test是否相等，表达式可写“a” “b“ 或（a，b） ifneq test，与ifeq相反 3、宏（函数）定义 Make脚本中的函数，按被调用的方式可分为三类 内置函数，即Make解释器内部定义好的函数，在任何脚本文件中可直接调用，调用的格式为：$(filename,param...)fname是函数的名称，param是参数，多个参数用逗号分隔 用户定义的、带参数的函数，使用define关键字进行定义，调用的格式为：$(call fname,param)call是调用的关键字，fname代表函数名称，param是函数参数，多个参数使用逗号分隔 用户定义的、不带参数的函数，该类函数也称之为宏，其调用的格式为：$(fname)即不使用call关键字，也不包含参数 4、内置符号和变量 内置符号 符号 意义 $@ target的名称 $* 和$@类似，只是不包含target的后缀 $^ 所有的先决条件名称，以空格分隔，如果先决条件中有重复，则自动去除重复 \\$? 有更新的先决条件列表，比如，有4个先决条件，其中有3个刚刚被修改过，则$?就代表刚刚被修改过的先决条件，以空格分隔 \\$+ 所有的先决条件，和$^类似，只是\\$+包含了重复的先决条件，而\\$^会自动去除重复的先决条件 $&lt; 第一个先决条件名称 内置变量 变量名称 意义 MAKE_VERSION make版本 CURDIR 执行make时的目录 MAKEFILE_LIST 本次make命令执行时，所有被包含的makefile列表 VARIABLE 所有的变量列表 5、模板目标 123456789101112.PHONY: testtest: f1.o f2.o main.o gcc -o main.bin fi.o f2.o main.of1.o: f1.c gcc f1.c f1.of2.o: f2.c gcc f2.c -c f2.o main.o: main.c gcc main.c -c main.o 使用模板目标后： 1234567OBJ = f1.o f2.o main.o.PHONY: testtest: ($OBJ) gcc $(OBJ) -o main.bin%.o: %.c gcc -c -o $@ $&lt; %.o就是模板目标，百分号是模板通配符，意思是所有.o文件。除了通配符外，代码中另外一个关键是使用符号常量$@和\\$^，前者代表目标名称，后者代表第一个先决条件的名称 6、目标特定的变量赋值 12345678CFLAGS = -c.PHONY: tar1tar1 : gcc $(CFLAGS) main.ctar2 : CFLAGS = tar2 : gcc $(CFLAGS) main.c CFLAGS被赋值为-c，其值在整个脚本文件范围内都是有效的。比如当Make tar1时，就会执行gcc -c main.c，但是在tar2目标中，我们希望能够执行gcc main.c，因此可以在tar2目标中对CFLAGS重新赋值，该赋值仅在tar2目标的命令中有效。这就是所谓的”目标特定“变量赋值，因为该赋值仅针对于该目标","categories":[],"tags":[{"name":"Linux基础知识笔记","slug":"Linux基础知识笔记","permalink":"http://yoursite.com/tags/Linux基础知识笔记/"}]},{"title":"Maven","slug":"Maven","date":"2018-01-21T02:09:49.000Z","updated":"2018-03-08T02:07:18.000Z","comments":true,"path":"2018/01/21/Maven/","link":"","permalink":"http://yoursite.com/2018/01/21/Maven/","excerpt":"Maven定义Maven是一个跨平台的项目管理工具。Maven主要服务基于Java平台的项目构建，依赖管理，项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。","text":"Maven定义Maven是一个跨平台的项目管理工具。Maven主要服务基于Java平台的项目构建，依赖管理，项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发，还是流行的敏捷模式，Maven都能大显身手。 Maven作为一个构建工具，它不仅仅能帮我们自动化构建，它还能够抽象构建过程，提供构建任务实现，它跨平台，意味着不管是在windows上，还是在Linux或者Mac上，都可以使用同样的命令，构建同样的项目，得到同样的结果，对外提供了一致的操作接口，这一切足以使它成为优秀的，流行的构建工具。 Maven不仅仅是构建工具，它还是一个依赖管理工具，还是一个项目信息管理工具。它提供了中央仓库，并能帮你自动下载构件。在开源的年代里，几乎任何一个Java应用都会借用一大堆第三方的开源类库，这些类库都通过依赖的方式引入到项目中来。它通过一个坐标系统准确定位每一个构件（Artifact），也就是通过一组坐标，Maven能够找到任何一个Java类库如jar文件，Maven给这个类库世界引入经纬，带来的秩序，于是我们就能够借助它帮助我们有序的管理依赖，轻松的解决那些繁杂的以来问题。通过Maven自动生成的站点和一些已有的插件，我们还能够轻松获得项目文档，测试报告，静态分析报告，源码版本日志报告，等等非常具有价值的项目信息。Maven还给全世界Java开发者提供了一个免费的中央仓库，我们可以找到几乎任何的流行开源类库。 编写POM就像Make的Makefile，Ant的build.xml，Maven项目的核心是pom.xml。POM的意思是项目对象模型（Project Object Model），在这个模型中我们定义项目的基本信息，描述项目如何构建，声明项目依赖，等等。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.maven-book&lt;/groupId&gt; &lt;artifactId&gt;ch-hello-world&lt;/artifaceId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Hello World Project&lt;/name&gt;&lt;/project&gt; 代码的第一行是XML头，指定了该xml文档的版本和编码方式。紧接着是project元素，project是所有pom.xml的根元素。注意该project根元素还声明了一些POM相关的命名空间及xsd元素，虽然这些属性不是必须的，但使用这些属性能够让第三方工具如IDE中的XML编辑器帮助我们快速编辑POM。 根元素下的第一个子元素modelVersion指定了当前POM模型的版本，对于Maven2来说，它只能是4.0.0. 这段代码中最重要的是groupId，artifactId和version三行。这三个元素定义了一个项目基本的坐标，就像我们的身份证号码一样，在Maven的世界，任何的jar，pom或者war都是基于这些基本的坐标进行区分的。 groupId定义了项目属于哪个组，这个组往往和项目所在的组织或公司存在关联，例如com.googlecode.myapp version指定了项目当前的版本，当前这个Hello World项目的版本是1.0-SNAPSHOT。SNAPSHOT意为快照，说明该项目还出于开发中，是不稳定的版本。 最后一个name元素声明了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每一个POM声明name，以方便信息交流。 Maven能让项目对象模型最大程度的与实际代码相独立，这在很大程度上避免了Java代码和POM代码相互影响。比如当项目需要升级版本的时候，只需要修改POM，不需要修改Java代码；而在POM稳定后，日常的Java代码开发工作基本不会涉及到POM的修改。 编写主代码关于Java主代码需要注意两点，首先，应该把项目主代码放到src/main/java/目录下，这是Maven的约定，遵循了该约定，就无需额外的配置，Maven会自动搜寻该目录找到项目主代码。其次，Java类的包名与之前在POM中定义的groupId和artifactId相吻合，一般来说，项目中Java类的包都应该基于项目的groupId和artifactId，虽然这不是必须的，但显然这样做更加清晰，更加符合逻辑，也方便搜索构件或者Java类。 编写测试代码为了使项目结构保持清晰，主代码与测试代码应该分别位于独立的目录，Maven项目中默认的主代码目录是src/main/java，对应的，Maven项目中默认的测试代码目录是src/test/java，因此，在编写测试用例之前，我们要先创建该目录。 在Java世界中，JUnit是事实上的单元测试标准。修改项目的POM，添加JUnit依赖。 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifact&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在XML代码中添加了dependencise元素，该元素下可以包含多个dependency元素声明项目的依赖。添加的JUnit依赖groupId是junit，artifactId是junit，version是4.7。有了这段声明，Maven就能够自动下载junit-4.7.jar。scope元素为依赖范围，当依赖范围是test的时候，表示该依赖只对测试有效。如果不声明依赖范围，默认值是compile，表示该依赖对主代码和测试代码都有效。 Maven2常用命令介绍建立项目（使用Archetype骨架） 建立项目的命令为：mvn archetype:generate -DarchetypeArtifactId=[项目类型] -DgroupId=[组识别] -DartifactId=[项目名称（包名称）] -Dversion=[版本] -Dpackage=[包] 项目类型（archetypeArtifactId）可以是下列选项 1.maven-archetype-j2ee-simple(J2EE项目) 2.maven-archetype-portlet(门户) 3.maven-archetype-quickstart(一般Java project) 4.maven-archetype-site(复杂站点) 5.maven-archetype-site-simple(简单站点) 6.maven-archetype-webapp(Java Web站点) groupId 用于项目的分组 artifactId 项目的名称，也就是包名称 version 版本 package 主要设定目录的层次 编译项目 #mvn compile 执行单元测试 #mvn test 在执行单元测试前，首先会执行编译动作 测试报告放在target\\site\\surefire-reports下 生成文档 #mvn javadoc:javadoc 生成的文档会在target\\site\\apidocs下 生成项目站点 #mvn site:site 生成站点放在\\target\\site下 清楚项目生成文件 #mvn clean:clean 打包文件 #mvn package 生成的包文件在target目录下（默认是jar文件） 将项目安装到本地仓库 #mvn install 发布项目 #mvn deploy 修改pom.xml调整编译参数 编译参数主要通过使用设定maven-compile-plugin来实现 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如上，可以设定编译使用UTF-8编码，源码为JDK1.5的版本，目标也为JDK1.5的版本。 设定使用UTF-8编码 除了编译外，还有资源文件、javadoc等都需要告诉maven使用UTF-8编码，可以设定如下两个插件 123456789101112&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 添加TestNG的测试框架支持 由于自动生成的项目为使用JUnit的测试框架，要使用TestNG的测试框架需要调整一下项目的依赖关系，并且设定项目使用的TestNG配置文件。 首先需删除对于JUnit的依赖 然后加入如下内容 1234567&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;5.8&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 由于TestNG需要不同的包支持JDK15和JDK14，所以要特别指定\\属性。如果没有指定\\属性，maven会自动下载最新版本。\\属性设定了依赖项的使用范围，如果设定为test表示仅测试时使用，在打包时不会打包该文件。可以使用插件maven-surefire-plugin设定testNG的配置文件位置，如下： 12345678&lt;plugin&gt; &lt;artifactId&gt;maven-surefile-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;suiteXmlFiles&gt; &lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt; &lt;/suiteXmlFiles&gt; &lt;/configuration&gt;&lt;/plugin&gt; 表示使用testng.xml作为testNG的配置文件","categories":[],"tags":[{"name":"Maven笔记","slug":"Maven笔记","permalink":"http://yoursite.com/tags/Maven笔记/"}]},{"title":"java Exception","slug":"java-Exception","date":"2018-01-19T02:15:27.000Z","updated":"2018-01-19T05:10:16.000Z","comments":true,"path":"2018/01/19/java-Exception/","link":"","permalink":"http://yoursite.com/2018/01/19/java-Exception/","excerpt":"java异常体系架构：","text":"java异常体系架构： Error是程序无法处理的错误，它是由JVM产生和抛出的。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止 Exception是程序本身可以处理的异常，这种异常分两大类： ​ 运行时异常是不检查异常，一般由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 ​ 非运行时异常从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能通过编译 异常处理throw ​ throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，就是打印异常消息和堆栈信息 ​ 用法：throw new Exception(“方法中存在Exception”) throws ​ throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用无力处理该异常的时候，也应该继续抛出 ​ 假设f方法抛出了A异常，则f方法有两种方式来处理A异常 ​ 1.throwsA ​ 谁调用f方法，谁处理A异常，f方法本身不处理A异常 ​ 2.try{……}catch(){……} ​ f方法本身自己来处理A异常 ​ 要抛出的异常必须是Throwable的子类 ​ throws A不表示f方法一定会抛出A类异常 ​ throws A不表示调用f方法时，必须得对A异常进行捕捉 ​ 假设A是RuntimeException的子类异常 ​ 由于RuntimeException的子类异常可以处理也可以不处理，所以编译器允许 你调用f方法时，对f方法抛出的RuntimeException子类异常不进行处理 ​ 建议： ​ 1.对throws出的所有异常进行处理 ​ 2.如果一个方法内部已经对A异常进行了处理，则就不要再throws A try catch finally ​ 1.try catch finally三个语句块均不能单独使用，try……catch、try……finally、try……catch……finally ​ 2.try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能互相访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外部 ​ 3.多个catch块的时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行 ​ 4.先catch子类异常再catch父类异常 ​ finally的作用： ​ 1.无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛出的异常类型一致，finally中的代码一定会得到执行 ​ 2.finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，能对程序的状态做统一的管理 ​ 3.通常在finally语句中可以进行资源的清除工作，如关闭打开的文件、删除临时文件等","categories":[],"tags":[{"name":"java异常","slug":"java异常","permalink":"http://yoursite.com/tags/java异常/"}]},{"title":"JsonNote","slug":"JsonNote","date":"2017-12-20T08:03:55.000Z","updated":"2018-01-20T09:19:32.000Z","comments":true,"path":"2017/12/20/JsonNote/","link":"","permalink":"http://yoursite.com/2017/12/20/JsonNote/","excerpt":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组","text":"JSON####Json语法 Json语法规则 ：Json语法是JavaScript对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 Json名称/值对 ：Json数据的书写格式：名称/值对（包括字段名称（在双引号中），后面写一个冒号，然后是值）”name” : “张三” Json值可以为： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true或false） 数组（在中括号中）：可以包含多个对象 12345&#123;&quot;sites&quot;:[ &#123;&quot;name&quot; : &quot;百度&quot; , &quot;url&quot; : &quot;www.baidu.com&quot;&#125;, &#123;&quot;name&quot; : &quot;谷歌&quot; , &quot;url&quot; : &quot;www.google.com&quot;&#125;, &#123;&quot;name&quot; : &quot;微博&quot; , &quot;url&quot; : &quot;www.weibo.com&quot;&#125;]&#125; Json使用JavaScript语法，和JavaScript创建对象数组，访问数组项，修改数据一样 Json文件的文件类型是：.json Json文件的MIME类型是：application/json Json对象 ： 对象语法：{“name” : “baidu” , “alexa” : 10000 , “site” : null} Json对象使用在大括号({})中书写 对象可以包含多个key/value(键值对) key必须是字符串，value可以是合法的Json数据类型(字符串，数字，对象，数组，布尔值或null) key和value中使用冒号(:)分隔 每个key/value对使用逗号(,)分隔 访问对象值：可以使用(.)来访问对象值，也可以使用([])来访问对象值 1234var myObj,x;myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; : 10000 , &quot;site&quot; : null&#125;;x = myObj.name;x = myObj[&quot;name&quot;]; 循环对象：可以使用(for-in)来循环对象的属性，在for-in循环对象的属性时，使用中括号([])来访问属性的值 1234567var myObj = &#123;&quot;name&quot; : &quot;baidu&quot; , &quot;alexa&quot; = 10000 , &quot;site&quot; = null&#125;;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;&lt;br&gt;&quot;;&#125;for(x in myObj)&#123; document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象：Json对象中可以包含另外一个Json对象，可以使用(.)或([])来访问嵌套的Json对象 1234567891011myObj = &#123; &quot;name&quot; : &quot;baidu&quot;, &quot;alexa&quot; : 10000, &quot;sites&quot; : &#123; &quot;site1&quot; : &quot;www.baidu.com&quot;, &quot;site2&quot; : &quot;mmm.baidu.com&quot;, &quot;site3&quot; : &quot;nnn.baidu.com&quot; &#125;&#125;;x = myObj.sites.site1;x = myObj.sites[&quot;site1&quot;]; 修改值：可以使用(.)或者([])来修改Json对象的值 删除对象属性：可以使用delete关键字来删除Json对象的属性delete myObj.sites.site1 Json数组 ： Json中数组值必须是合法的Json数据类型，JavaScript中，数组值可以是Json数据类型，也可以是JavaScript的表达式，包括函数，日期和undefined Json对象中的数组：对象属性的值可以是一个数组；可以使用索引值来访问数组 循环数组：可以使用(for-in)来访问数组，也可以使用for循环 123for(i in myObj.sites)&#123; x += myObj.sites[i] + &quot;&lt;br&gt;&quot;;&#125; 嵌套Json对象中的数组：可以使用两个for-in或for循环来访问 修改数组值：可以使用索引值来修改数组值 删除数组元素：可以使用delete关键字来删除数组元素 JSON.parse() Json通常用于与服务器端交换数据，在接收服务器数据时一般是字符串，可以使用JSON.parse()方法将数据转换为JavaScript对象 语法：JSON.parse(text[,reviver]) 参数说明：text：必需，一个有效的字符串；reviver：可选，一个转换结果的函数，将为对象的每个成员调用此函数 从服务器端接收Json数据：可以使用Ajax从服务器请求Json数据，并解析为JavaScript对象 异常：解析数据：Json不能存储Date对象，如果需要存储，需要将其转换为字符串，之后再将字符串转换为Date对象 123456789101112var text = &apos;&#123; &quot;name&quot; : &quot;baidu&quot; , &quot;initDate&quot; : &quot;2000-01-12&quot; , &quot;site&quot; : www.baidu.com&quot; &#125;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;日期:&quot; + obj.initDate;//也可以启用reviver参数var obj = JSON.parse(text,function(key,value)&#123; if(key == &quot;initDate&quot;)&#123; return new Date(value); &#125;else&#123; return value; &#125;&#125;); JSON.stringify() 在向服务器端发送数据时一般是字符串，可以使用JSON.stringify()方法将JavaScript对象转换成字符串 语法：JSON.stringify(value[,replacer[,space]]) 参数说明： value：必需，一个有效的Json字符串 replacer：可选，用于转换结果的函数或数组。如果replacer为函数，则JSON.stringify将调用该函数，并传入每个成员的键和值，使用返回值而不是原始值，如果此函数返回undefined，则排除成员；根对象的键是一个空字符串：””。如果replacer是一个数组，则仅转换该数组中具有键值的成员，成员的转换顺序与键在数组中的顺序一样，当value参数也为数组时，将忽略replacer数组 space：可选，文本添加缩进、空格和换行符，如果space是一个数字，则返回文本在每个级别缩进指定数目的空格，如果space大于10，则文本缩进10个空格，也可以使用非数字：\\t Json使用 由于Json语法是JavaScript语法的自己，JavaScript函数eval()可用于将Json文本转换为JavaScript对象 eval()函数使用的是JavaScript编译器，可解析Json文本，然后生成JavaScript对象，必须把文本包围在括号中var obj = eval(&quot;(&quot;+txt+&quot;)&quot;);，eval()函数可编译并执行任何JavaScript代码，这隐藏了潜在的安全问题 JSONP Jsonp(JSON with Padding)是Json的一种“使用模式”，可以让网页从别的域名(网站)那获取资料，即跨域读取数据","categories":[],"tags":[{"name":"JsonNote","slug":"JsonNote","permalink":"http://yoursite.com/tags/JsonNote/"}]},{"title":"ajaxNote","slug":"ajaxNote","date":"2017-11-19T05:16:04.000Z","updated":"2018-01-20T07:59:54.000Z","comments":true,"path":"2017/11/19/ajaxNote/","link":"","permalink":"http://yoursite.com/2017/11/19/ajaxNote/","excerpt":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行","text":"Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML） Ajax不是新的编程语言，而是一种使用现有标准的新方法 Ajax最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 Ajax不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行 XMLHttpRequest对象：用于在后台与服务器交换数据 ​ 创建XMLHttpRequest对象： ​ 语法：variable = new XMLHttpRequest(); ​ var xmlHttp; ​ if(window.XMLHttpRequest){ ​ xmlHttp = new XMLHttpRequest(); ​ } XMLHttpRequest请求：向服务器发送请求：open(),send() ​ xmlHttp.open(method,url,async)规定请求的类型、URL以及是否异步处理请求 ​ method：请求的类型：GET或POST ​ url：文件在服务器上的位置 ​ async：true（异步）或false（同步） ​ xmlHttp.send(string)将请求发送到服务器 ​ string：仅用于POST请求 ​ GET还是POST？ ​ 与POST相比，GET更简单也更快，并且在大部分情况下都能用。然而，在以下情况下请使用POST请求： ​ 1.无法使用缓存文件（更新服务器上的文件或数据库） ​ 2.向服务器发送大量数据（POST请求没有数据量限制） ​ 3.发送包含未知字符的用户输入时，POST比GET更稳定也更可靠 ​ 如果希望通过GET方法发送信息，请向URL添加信息 ​ xmlHttp.open(&#39;GET&#39;,&#39;url?name=name&amp;pas=pas&#39;,true) ​ xmlHttp.send() ​ 如果希望像HTML表单那样POST数据，使用setRequestHeader()来添加http头部，然后在send()方法中规定要发送的数据 ​ xmlHttp.setRequestHeader(header,value)向请求添加http头 ​ header：规定头的名称 ​ value：规定头的值 ​ xmlHttp.open(&#39;POST&#39;,&#39;url&#39;,true); ​ xmlHttp.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;); ​ xmlHttp.send(&#39;name=name&amp;pas=pas&#39;); ​ 通过Ajax，JavaScript无需等待服务器的响应，而是在等待服务器响应时执行其他脚本，当响应就绪后进行处理。 XMLHttpRequest响应 ​ 如需要获得来自服务器的响应，使用XMLHttpRequest对象的responseText或responseXML属性 ​ responseText属性：返回字符串形式的响应数据 ​ responseXML属性：返回XML形式的响应数据 XMLHttpRequest readyState ​ onreadystatechange事件： ​ 当请求被发送到服务器时，我们需要执行一些基于响应的任务 ​ 每当readyState改变时，就会触发onreadystatechange事件 ​ readyState属性存有XMLHttpRequest的状态信息 ​ XMLHttpRequest对象的三个重要属性： ​ 1.onreadystatechange 存储函数（或函数名），每当readyState属性改变时，就会调用这个函数 ​ 2.readyState 存有XMLHttpRequest的状态 ​ 0：请求未初始化 ​ 1：服务器连接已建立 ​ 2：请求已接收 ​ 3：请求处理中 ​ 4：请求已完成，且响应已就绪 ​ 3.status 状态 200：’OK‘; 400：未找到页面 回调函数 ​ 回调函数是一种以参数形式传递给另一个函数的函数 ​","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Typora","slug":"Typora","date":"2017-11-12T02:54:04.000Z","updated":"2018-01-21T02:04:22.000Z","comments":true,"path":"2017/11/12/Typora/","link":"","permalink":"http://yoursite.com/2017/11/12/Typora/","excerpt":"##Markdown语法 下标 ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry:","text":"##Markdown语法 下标 ：使用~包裹，例如：H~2~O 上标 ：使用^包裹，例如：y^2^ 插入表情 ：使用:happy:输入:happy: :sad: :cry: 下划线 ：使用&lt;u&gt;Underline&lt;/u&gt; 产生下划线Underline 删除线 ：使用~~包裹的文本具有删除的样式删除文本 代码 ：使用`包裹的内容将会以代码样式显示 ​ pringtf() ​ 输入12345```javapublic Class HelloWorld&#123; System.out.println(&quot;Hello world!&quot;);&#125; 强调 ：使用两个*号包裹的内容会被强调 斜体 ：使用*和_包裹的内容会是斜体显示。 ​ 斜体 要显示号可以使用转义\\ 插入图片 ：可以通过拖拉的方式加入图片 插入URL连接 ：使用尖括号包裹的url将产生一个连接，例如： 如果是标准的url，则会自动产生连接 目录列表Table of Contents ：输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容 水平分割线 ：使用*或者—，然后回车，来产生水平分割线 标注 ：可以对一个词语进行[^标注] [^标注]：这是一个标注 表格 ： 一 张 表 一 张 表 数学表达式块 ：输入两个美元符号，然后回车，就可以输入数学表达式块 任务列表 ：-[]吃饭创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者未完成 吃饭 []逛街 列表 ：输入+，-，*创建无序的列表，使用任意数字开头，创建有序列表。例如： 无 序 列 表 有 序 列 表 块引用 ：使用&gt;来插入块引用 这是一个块引用 标题 ：使用#表示一级标题，##表示二级标题，依次类推，共6个标题","categories":[],"tags":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://yoursite.com/tags/Markdown语法/"}]},{"title":"Regex","slug":"Regex","date":"2017-10-20T02:57:32.000Z","updated":"2018-01-20T04:43:50.000Z","comments":true,"path":"2017/10/20/Regex/","link":"","permalink":"http://yoursite.com/2017/10/20/Regex/","excerpt":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置","text":"正则表达式例 ^[0-9]+abc$ ^为匹配输入字符串的开始位置 [0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或多个 abc$匹配字母abc并以abc结尾 $为匹配输入字符串的结束位置 使用正则表达式： *测试字符串内的模式（可以测试输入字符串，以查看字符串内是否出现电话模式或信用卡模式，这称为数据验证） *替换文本（可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它） *基于模式匹配从字符串中提取字符串（可以查找文档内或输入域内特定的文本） java.util.regex包主要包括以下三个类： 1.Pattern类：Pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法，要创建一个Pattern对象，必须先调用其公共静态编译方法，它返回一个Pattern对象，该方法接受一个正则表达式作为它的第一个参数 2.Matcher类：Matcher对象是输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher类也没有公共构造方法。需要调用Pattern对象的matcher方法来获得一个Matcher对象 3.PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误 捕获组： 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建，捕获组是通过从左至右计算其开括号来编号。例：((A)(B(C)))有四个组 可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多少个捕获组。(group(0))它代表整个表达式，但不包括在groupCount的返回值中 正则表达式语法： 其他语言中双反斜杠表示：在正则表达式中插入一个普通的反斜杠。在java中双反斜杠表示：插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。所以java的转义需要双反斜杠，java表示一位数字的正则表达式是双反斜杠d，而表示反斜杠则是四条反斜线 字符 含义 \\ 将下一字符标记为特殊字符 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结束的位置 * 零次或多次匹配前面的字符或子表达式 + 一次或多次匹配前面的字符或子表达式 ? 零次或一次匹配前面的字符或子表达式 {n} n是非负整数，正好匹配n次 {n,} n是非负整数，至少匹配n次 {n,m} n和m是非负整数，至少匹配n次，至多匹配m次 ? 在限定字符后，表示匹配模式是“非贪心模式”，即匹配尽可能短的字符串，默认是“贪心模式” . 匹配除了“\\r\\n”之外的任何单个字符 [xyz] 字符集，匹配包含的任一字符 [^xyz] 反字符集，匹配未包含的任一字符 [a-z] 字符范围，匹配指定范围内的任何字符 \\b 匹配一个字的边界，即字与空格间的位置 \\d 数字字符匹配，等效于[0-9] \\w 匹配任何字类字符，包括下划线，等效于[A-Za-z0-9] 具体类的方法参见JDK","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Git","slug":"Git","date":"2017-10-10T02:54:35.000Z","updated":"2018-01-20T03:41:10.000Z","comments":true,"path":"2017/10/10/Git/","link":"","permalink":"http://yoursite.com/2017/10/10/Git/","excerpt":"##Git Git是分布式版本控制系统Git命令","text":"##Git Git是分布式版本控制系统Git命令 git config --global user.name 设置用户名 git config --global user.email 设置用户邮箱 pwd 显示当前目录 git init 初始化git仓库 ls -ah 查看隐藏目录 git add &lt;文件名&gt; 添加文件 git commit -m &#39;本次提交说明&#39; 把文件提交到git仓库 可以同时提交多个文件，add多个，一次提交 git status 掌握仓库当前的状态 git diff 查看difference git log 查看历史纪录 显示从最近到最远的提交日志 git log --pretty=oneline 显示提交的版本号 git reset --hard HEAD^ 回退一次 HEAD^^ 回退两次…… git reset --hard 版本号 可以回到已经退过的最新版本 git reflog 记录每一次命令 HEAD指向的版本是当前的版本 cat &lt;文件名&gt; 查看文件中的内容 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 1.readme.txt自修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态 2.readme.txt已经添加到暂存区后，又做了修改，现在撤销修改就回到添加到暂存区后的状态 用命令git reset HEAD file可以把暂存区的修改撤销掉，重新放回工作区 rm &lt;文件名&gt; 删除文件 确实要从版本库中删除该文件，那就用命令git rm 删掉，并且git commit git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原” ssh-keygen -t rsa -C &#39;youremail@example.com&#39; 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的密钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以放心告诉任何人 git remote add origin git@github.com:Github账号/learngit.git 建立远程连接 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程 git push -u origin master git push origin master git checkout -b dev 创建dev分支 git checkout 命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev git branch 命令查看当前分支 git checkout master 切换回master分支 git merge 命令用于合并指定分支到当前分支 git merge dev git branch -d dev 删除dev分支 git log --graph 命令可以看到分支合并图 git clone git@github.com:Github账号/learngit.git 从远程库克隆","categories":[],"tags":[{"name":"Git命令","slug":"Git命令","permalink":"http://yoursite.com/tags/Git命令/"}]}]}